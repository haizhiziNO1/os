<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <!--<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>-->
    <title>08-锁：并发操作中，解决数据同步的四种方法</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <style>
        html {
            color: #333;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-rendering: optimizelegibility;
            font-family: Helvetica Neue, PingFang SC, Verdana, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, sans-serif
        }

        html.borderbox *,
        html.borderbox :after,
        html.borderbox :before {
            box-sizing: border-box
        }

        article,
        aside,
        blockquote,
        body,
        button,
        code,
        dd,
        details,
        dl,
        dt,
        fieldset,
        figcaption,
        figure,
        footer,
        form,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        header,
        hr,
        input,
        legend,
        li,
        menu,
        nav,
        ol,
        p,
        pre,
        section,
        td,
        textarea,
        th,
        ul {
            margin: 0;
            padding: 0
        }

        article,
        aside,
        details,
        figcaption,
        figure,
        footer,
        header,
        menu,
        nav,
        section {
            display: block
        }

        audio,
        canvas,
        video {
            display: inline-block
        }

        body,
        button,
        input,
        select,
        textarea {
            font: 300 1em/1.8 PingFang SC, Lantinghei SC, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, Helvetica, sans-serif
        }

        button::-moz-focus-inner,
        input::-moz-focus-inner {
            padding: 0;
            border: 0
        }

        table {
            border-collapse: collapse;
            border-spacing: 0
        }

        fieldset,
        img {
            border: 0
        }

        blockquote {
            position: relative;
            color: #999;
            font-weight: 400;
            border-left: 1px solid #1abc9c;
            padding-left: 1em;
            margin: 1em 3em 1em 2em
        }

        @media only screen and (max-width: 640px) {
            blockquote {
                margin: 1em 0
            }
        }

        abbr,
        acronym {
            border-bottom: 1px dotted;
            font-variant: normal
        }

        abbr {
            cursor: help
        }

        del {
            text-decoration: line-through
        }

        address,
        caption,
        cite,
        code,
        dfn,
        em,
        th,
        var {
            font-style: normal;
            font-weight: 400
        }

        ol,
        ul {
            list-style: none
        }

        caption,
        th {
            text-align: left
        }

        q:after,
        q:before {
            content: ""
        }

        sub,
        sup {
            font-size: 75%;
            line-height: 0;
            position: relative
        }

        :root sub,
        :root sup {
            vertical-align: baseline
        }

        sup {
            top: -.5em
        }

        sub {
            bottom: -.25em
        }

        a {
            color: #1abc9c
        }

        a:hover {
            text-decoration: underline
        }

        .typo a {
            border-bottom: 1px solid #1abc9c
        }

        .typo a:hover {
            border-bottom-color: #555;
            color: #555
        }

        .typo a:hover,
        a,
        ins {
            text-decoration: none
        }

        .typo-u,
        u {
            text-decoration: underline
        }

        mark {
            background: #fffdd1;
            border-bottom: 1px solid #ffedce;
            padding: 2px;
            margin: 0 5px
        }

        code,
        pre,
        pre tt {
            font-family: Courier, Courier New, monospace
        }

        pre {
            background: hsla(0, 0%, 97%, .7);
            border: 1px solid #ddd;
            padding: 1em 1.5em;
            display: block;
            -webkit-overflow-scrolling: touch
        }

        hr {
            border: none;
            border-bottom: 1px solid #cfcfcf;
            margin-bottom: .8em;
            height: 10px
        }

        .typo-small,
        figcaption,
        small {
            font-size: .9em;
            color: #888
        }

        b,
        strong {
            font-weight: 700;
            color: #000
        }

        [draggable] {
            cursor: move
        }

        .clearfix:after,
        .clearfix:before {
            content: "";
            display: table
        }

        .clearfix:after {
            clear: both
        }

        .clearfix {
            zoom: 1
        }

        .textwrap,
        .textwrap td,
        .textwrap th {
            word-wrap: break-word;
            word-break: break-all
        }

        .textwrap-table {
            table-layout: fixed
        }

        .serif {
            font-family: Palatino, Optima, Georgia, serif
        }

        .typo-dl,
        .typo-form,
        .typo-hr,
        .typo-ol,
        .typo-p,
        .typo-pre,
        .typo-table,
        .typo-ul,
        .typo dl,
        .typo form,
        .typo hr,
        .typo ol,
        .typo p,
        .typo pre,
        .typo table,
        .typo ul,
        blockquote {
            margin-bottom: 1rem
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-family: PingFang SC, Helvetica Neue, Verdana, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, sans-serif;
            color: #000;
            line-height: 1.35
        }

        .typo-h1,
        .typo-h2,
        .typo-h3,
        .typo-h4,
        .typo-h5,
        .typo-h6,
        .typo h1,
        .typo h2,
        .typo h3,
        .typo h4,
        .typo h5,
        .typo h6 {
            margin-top: 1.2em;
            margin-bottom: .6em;
            line-height: 1.35
        }

        .typo-h1,
        .typo h1 {
            font-size: 2em
        }

        .typo-h2,
        .typo h2 {
            font-size: 1.8em
        }

        .typo-h3,
        .typo h3 {
            font-size: 1.6em
        }

        .typo-h4,
        .typo h4 {
            font-size: 1.4em
        }

        .typo-h5,
        .typo-h6,
        .typo h5,
        .typo h6 {
            font-size: 1.2em
        }

        .typo-ul,
        .typo ul {
            margin-left: 1.3em;
            list-style: disc
        }

        .typo-ol,
        .typo ol {
            list-style: decimal;
            margin-left: 1.9em
        }

        .typo-ol ol,
        .typo-ol ul,
        .typo-ul ol,
        .typo-ul ul,
        .typo li ol,
        .typo li ul {
            margin-bottom: .8em;
            margin-left: 2em
        }

        .typo-ol ul,
        .typo-ul ul,
        .typo li ul {
            list-style: circle
        }

        .typo-table td,
        .typo-table th,
        .typo table caption,
        .typo table td,
        .typo table th {
            border: 1px solid #ddd;
            padding: .5em 1em;
            color: #666
        }

        .typo-table th,
        .typo table th {
            background: #fbfbfb
        }

        .typo-table thead th,
        .typo table thead th {
            background: hsla(0, 0%, 95%, .7)
        }

        .typo table caption {
            border-bottom: none
        }

        .typo-input,
        .typo-textarea {
            -webkit-appearance: none;
            border-radius: 0
        }

        .typo-em,
        .typo em,
        caption,
        legend {
            color: #000;
            font-weight: inherit
        }

        .typo-em {
            position: relative
        }

        .typo-em:after {
            position: absolute;
            top: .65em;
            left: 0;
            width: 100%;
            overflow: hidden;
            white-space: nowrap;
            content: "\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB"
        }

        .typo img {
            max-width: 100%
        }

        .common-content {
            font-weight: 400;
            color: #353535;
            line-height: 1.75rem;
            white-space: normal;
            word-break: normal;
            font-size: 1rem
        }

        .common-content img {
            display: block;
            max-width: 100%;
            background-color: #eee
        }

        .common-content audio,
        .common-content video {
            width: 100%;
            background-color: #eee
        }

        .common-content center,
        .common-content font {
            margin-top: 1rem;
            display: inline-block
        }

        .common-content center {
            width: 100%
        }

        .common-content pre {
            margin-top: 1rem;
            padding-left: 0;
            padding-right: 0;
            position: relative;
            overflow: hidden
        }

        .common-content pre code {
            font-size: .8rem;
            font-family: Consolas, Liberation Mono, Menlo, monospace, Courier;
            display: block;
            width: 100%;
            box-sizing: border-box;
            padding-left: 1rem;
            padding-right: 1rem;
            overflow-x: auto
        }

        .common-content hr {
            border: none;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            border-top: 1px solid #f5f5f5;
            height: 1px;
            background: none
        }

        .common-content b,
        .common-content h1,
        .common-content h2,
        .common-content h3,
        .common-content h4,
        .common-content h5,
        .common-content strong {
            font-weight: 700
        }

        .common-content h1,
        .common-content h2 {
            font-size: 1.125rem;
            margin-bottom: .45rem
        }

        .common-content h3,
        .common-content h4,
        .common-content h5 {
            font-size: 1rem;
            margin-bottom: .45rem
        }

        .common-content p {
            font-weight: 400;
            color: #353535;
            margin-top: .15rem
        }

        .common-content .orange {
            color: #ff5a05
        }

        .common-content .reference {
            font-size: 1rem;
            color: #888
        }

        .custom-rich-content h1 {
            margin-top: 0;
            font-weight: 400;
            font-size: 15.25px;
            border-bottom: 1px solid #eee;
            line-height: 2.8
        }

        .custom-rich-content li,
        .custom-rich-content p {
            font-size: 14px;
            color: #888;
            line-height: 1.6
        }

        table.hljs-ln {
            margin-bottom: 0;
            border-spacing: 0;
            border-collapse: collapse
        }

        table.hljs-ln,
        table.hljs-ln tbody,
        table.hljs-ln td,
        table.hljs-ln tr {
            box-sizing: border-box
        }

        table.hljs-ln td {
            padding: 0;
            border: 0
        }

        table.hljs-ln td.hljs-ln-numbers {
            min-width: 15px;
            color: rgba(27, 31, 35, .3);
            text-align: right;
            white-space: nowrap;
            cursor: pointer;
            user-select: none
        }

        table.hljs-ln td.hljs-ln-code,
        table.hljs-ln td.hljs-ln-numbers {
            font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;
            font-size: 12px;
            line-height: 20px;
            vertical-align: top
        }

        table.hljs-ln td.hljs-ln-code {
            position: relative;
            padding-right: 10px;
            padding-left: 10px;
            overflow: visible;
            color: #24292e;
            word-wrap: normal;
            white-space: pre
        }

        video::-webkit-media-controls {
            overflow: hidden !important
        }

        video::-webkit-media-controls-enclosure {
            width: calc(100% + 32px);
            margin-left: auto
        }

        ._29HP61GA_0 {
            max-width:800px;
            margin:0 auto;
            margin-bottom: 20px;
            font-weight: 400;
            color: #353535;
            line-height: 1.76;
            white-space: normal;
            word-break: normal;
            font-size: 17px;
            -webkit-transition: background-color .3s ease;
            transition: background-color .3s ease
        }

        ._29HP61GA_0 .MathJax_Display {
            overflow: auto
        }

        ._29HP61GA_0 .poster {
            position: fixed;
            left: -10000px;
            top: -10000px;
            overflow: hidden;
            padding: 1rem;
            background: #ececec
        }

        ._29HP61GA_0 .richcontent-pre-copy {
            font-size: 13px;
            color: #888;
            position: absolute;
            right: 1em;
            top: .5em;
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none
        }

        ._29HP61GA_0 .richcontent-pre-copy .iconfont {
            font-size: 12px;
            margin-right: .2em
        }

        ._29HP61GA_0 a {
            color: #fa8919;
            border-bottom: 1px solid #fa8919
        }

        ._29HP61GA_0 img {
            display: block;
            max-width: 100%;
            position: relative;
            left: 50%;
            -webkit-transform: translateX(-50%);
            transform: translateX(-50%);
            background-color: #eee;
            vertical-align: top;
            border-radius: 0
        }

        ._29HP61GA_0 audio,
        ._29HP61GA_0 video {
            width: 100%;
            background-color: #eee
        }

        ._29HP61GA_0 pre {
            margin-top: 16px;
            padding: 34px 0 0;
            margin-bottom: 30px;
            position: relative;
            border-radius: 6px;
            background: rgba(246, 247, 251, .749);
            border: 0
        }

        ._29HP61GA_0 pre code {
            font-size: 12px;
            font-family: Consolas, Liberation Mono, Menlo, monospace, Courier;
            display: block;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
            margin-left: 16px;
            margin-right: 16px;
            overflow-x: scroll
        }

        ._29HP61GA_0 pre code:after {
            content: "";
            height: 30px;
            width: 100%;
            display: block
        }

        ._29HP61GA_0 hr {
            border: none;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            border-top: 1px solid #f5f5f5;
            height: 1px;
            background: none
        }

        ._29HP61GA_0 h1,
        ._29HP61GA_0 h2,
        ._29HP61GA_0 h3,
        ._29HP61GA_0 h4,
        ._29HP61GA_0 h5 {
            margin-bottom: 20px;
            margin-top: 0;
            font-weight: 700
        }

        ._29HP61GA_0 b,
        ._29HP61GA_0 strong {
            font-weight: 700
        }

        ._29HP61GA_0 h1 {
            font-size: 21px
        }

        ._29HP61GA_0 h2 {
            font-size: 20px
        }

        ._29HP61GA_0 h3 {
            font-size: 19px
        }

        ._29HP61GA_0 h4 {
            font-size: 18px
        }

        ._29HP61GA_0 h5 {
            font-size: 17px
        }

        ._29HP61GA_0 center,
        ._29HP61GA_0 p {
            font-weight: 400;
            color: #353535;
            margin-top: 0;
            margin-bottom: 30px;
            word-break: break-word
        }

        ._29HP61GA_0 center {
            text-align: center
        }

        ._29HP61GA_0 blockquote {
            margin-top: 0;
            margin-bottom: 34px;
            border-left: 3px solid #e8e8e8;
            padding-left: 17px;
            color: #353535
        }

        ._29HP61GA_0 blockquote p {
            margin-top: 0;
            margin-bottom: 0
        }

        ._29HP61GA_0 ol,
        ._29HP61GA_0 ul {
            margin-bottom: 30px
        }

        ._29HP61GA_0 ol p,
        ._29HP61GA_0 ul p {
            margin-top: 0;
            margin-bottom: 0
        }

        ._29HP61GA_0 ol {
            list-style: decimal;
            margin-left: 20px
        }

        ._29HP61GA_0 ul li {
            padding-left: 17px;
            position: relative;
            margin-bottom: 10px
        }

        ._29HP61GA_0 ul li:after {
            content: "";
            height: 6px;
            width: 6px;
            border-radius: 50%;
            background: #353535;
            position: absolute;
            top: 10px;
            left: 0
        }

        ._29HP61GA_0 .orange {
            color: #fa8919
        }

        ._29HP61GA_0 .reference {
            color: #888
        }

        ._29HP61GA_0 .m-right {
            text-align: right
        }

        ._29HP61GA_0 .m-center {
            text-align: center;
            display: block
        }

        ._29HP61GA_0 .m-gray {
            color: #888
        }

        ._29HP61GA_0 .m-small {
            font-size: 15px
        }

        ._29HP61GA_0 table.hljs-ln {
            margin-bottom: 0;
            border-spacing: 0;
            border-collapse: collapse
        }

        ._29HP61GA_0 table.hljs-ln,
        ._29HP61GA_0 table.hljs-ln tbody,
        ._29HP61GA_0 table.hljs-ln td,
        ._29HP61GA_0 table.hljs-ln tr {
            -webkit-box-sizing: border-box;
            box-sizing: border-box
        }

        ._29HP61GA_0 table.hljs-ln td {
            padding: 0;
            border: 0
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-numbers {
            min-width: 15px;
            font-size: 12px;
            color: rgba(27, 31, 35, .3);
            text-align: right;
            white-space: nowrap;
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-code,
        ._29HP61GA_0 table.hljs-ln td.hljs-ln-numbers {
            font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;
            line-height: 20px;
            vertical-align: top
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-code {
            position: relative;
            padding-right: 10px;
            padding-left: 10px;
            overflow: visible;
            font-size: 13px;
            color: #666;
            word-wrap: normal;
            white-space: pre
        }

    </style>
</head>
<body>
<div class="_29HP61GA_0">
<h1>08-锁：并发操作中，解决数据同步的四种方法</h1>
<p>你好，我是LMOS。</p><p>我们在前面的课程中探索了，开发操作系统要了解的最核心的硬件——CPU、MMU、Cache、内存，知道了它们的工作原理。在程序运行中，它们起到了至关重要的作用。</p><p>在开发我们自己的操作系统以前，还不能一开始就把机器跑起来，而是先要弄清楚数据同步的问题。如果不解决掉数据同步的问题，后面机器跑起来，就会出现很多不可预知的结果。</p><p>通过这节课，我会给你讲清楚为什么在并发操作里，很可能得不到预期的访问数据，还会带你分析这个问题的原因以及解决方法。有了这样一个研究、解决问题的过程，对最重要的几种锁（<strong>原子变量，关中断，信号量，自旋锁</strong>），你就能做到心中有数了。</p><h2>非预期结果的全局变量</h2><p>来看看下面的代码，描述的是一个线程中的函数和中断处理函数，它们分别对一个全局变量执行加1操作，代码如下。</p><pre><code>int a = 0;
void interrupt_handle()
{
    a++;
}
void thread_func()
{
    a++;
}

</code></pre><p>首先我们梳理一下编译器的翻译过程，通常编译器会把a++语句翻译成这3条指令。</p><p>1.把a加载某个寄存器中。</p><p>2.这个寄存器加1。</p><p>3.把这个寄存器写回内存。</p><p>那么不难推断，可能导致结果不确定的情况是这样的：thread_func函数还没运行完第2条指令时，中断就来了。</p><p>因此，CPU转而处理中断，也就是开始运行interrupt_handle函数，这个函数运行完a=1，CPU还会回去继续运行第3条指令，此时a依然是1，这显然是错的。</p><!-- [[[read_end]]] --><p>下面来看一下表格，你就明白了。<br>
<img src="https://static001.geekbang.org/resource/image/79/4c/79bfa1d036ebb27yy17ae3edf768ba4c.jpeg" alt=""></p><p>显然在t2时刻发生了中断，导致了t2到t4运行了interrupt_handle函数，t5时刻thread_func又恢复运行，导致interrupt_handle函数中a的操作丢失，因此出错。</p><h2>方法一：原子操作 拿下单体变量</h2><p>要解决上述场景中的问题，有这样两种思路。一种是<strong>把a++变成原子操作</strong>，这里的原子是不可分隔的，也就是说要a++这个操作不可分隔，即a++要么不执行，要么一口气执行完；另一种就是<strong>控制中断</strong>，比如在执行a++之前关掉中断，执行完了之后打开中断。</p><p>我们先来看看原子操作，显然靠编译器自动生成原子操作不太可能。第一，编译器没有这么智能，能检测哪个变量需要原子操作；第二，编译器必须要考虑代码的移植性，例如有些硬件平台支持原子操作的机器指令，有的硬件平台不支持原子操作。</p><p>既然实现原子操作无法依赖于具体编译器，那就需要我们自己动手，x86平台支持很多原子指令，我们只需要直接应用这些指令，比如原子加、原子减，原子读写等，用汇编代码写出对应的原子操作函数就行了。</p><p>好在现代C语言已经支持嵌入汇编代码，可以<strong>在C函数中按照特定的方式嵌入汇编代码</strong>了，实现原子操作就更方便了，代码如下。</p><pre><code>//定义一个原子类型
typedef struct s_ATOMIC{
    volatile s32_t a_count; //在变量前加上volatile，是为了禁止编译器优化，使其每次都从内存中加载变量
}atomic_t;
//原子读
static inline s32_t atomic_read(const atomic_t *v)
{        
        //x86平台取地址处是原子
        return (*(volatile u32_t*)&amp;(v)-&gt;a_count);
}
//原子写
static inline void atomic_write(atomic_t *v, int i)
{
        //x86平台把一个值写入一个地址处也是原子的 
        v-&gt;a_count = i;
}
//原子加上一个整数
static inline void atomic_add(int i, atomic_t *v)
{
        __asm__ __volatile__(&quot;lock;&quot; &quot;addl %1,%0&quot;
                     : &quot;+m&quot; (v-&gt;a_count)
                     : &quot;ir&quot; (i));
}
//原子减去一个整数
static inline void atomic_sub(int i, atomic_t *v)
{
        __asm__ __volatile__(&quot;lock;&quot; &quot;subl %1,%0&quot;
                     : &quot;+m&quot; (v-&gt;a_count)
                     : &quot;ir&quot; (i));
}
//原子加1
static inline void atomic_inc(atomic_t *v)
{
        __asm__ __volatile__(&quot;lock;&quot; &quot;incl %0&quot;
                       : &quot;+m&quot; (v-&gt;a_count));
}
//原子减1
static inline void atomic_dec(atomic_t *v)
{
       __asm__ __volatile__(&quot;lock;&quot; &quot;decl %0&quot;
                     : &quot;+m&quot; (v-&gt;a_count));
}

</code></pre><p><strong>以上代码中，加上lock前缀的addl、subl、incl、decl指令都是原子操作，lock前缀表示锁定总线。</strong></p><p>我们还是来看看GCC支持嵌入汇编代码的模板，不同于其它C编译器支持嵌入汇编代码的方式，为了优化用户代码，GCC设计了一种特有的嵌入方式，它规定了汇编代码嵌入的形式和嵌入汇编代码需要由哪几个部分组成，如下面代码所示。</p><pre><code>__asm__ __volatile__(代码部分:输出部分列表: 输入部分列表:损坏部分列表);
</code></pre><p>可以看到代码模板从__asm__开始（当然也可以是asm），紧跟着__volatile__，然后是跟着一对括号，最后以分号结束。括号里大致分为4个部分：</p><p>1.汇编代码部分，这里是实际嵌入的汇编代码。</p><p>2.输出列表部分，让GCC能够处理C语言左值表达式与汇编代码的结合。</p><p>3.输入列表部分，也是让GCC能够处理C语言表达式、变量、常量，让它们能够输入到汇编代码中去。</p><p>4.损坏列表部分，告诉GCC汇编代码中用到了哪些寄存器，以便GCC在汇编代码运行前，生成保存它们的代码，并且在生成的汇编代码运行后，恢复它们（寄存器）的代码。</p><p>它们之间用冒号隔开，如果只有汇编代码部分，后面的冒号可以省略。但是有输入列表部分而没有输出列表部分的时候，输出列表部分的冒号就必须要写，否则GCC没办法判断，同样的道理对于其它部分也一样。</p><p>这里不会过多展开讲这个技术，详情可参阅<a href="https://www.gnu.org/manual/manual.html">GCC手册</a>。你可以重点看GAS相关的章节。</p><p>下面将用上面一个函数atomic_add为例子说一下，如下所示。</p><pre><code>static inline void atomic_add(int i, atomic_t *v)
{
        __asm__ __volatile__(&quot;lock;&quot; &quot;addl %1,%0&quot;
                     : &quot;+m&quot; (v-&gt;a_count)
                     : &quot;ir&quot; (i));
}
//&quot;lock;&quot; &quot;addl %1,%0&quot; 是汇编指令部分，%1,%0是占位符，它表示输出、输入列表中变量或表态式，占位符的数字从输出部分开始依次增加，这些变量或者表态式会被GCC处理成寄存器、内存、立即数放在指令中。 
//: &quot;+m&quot; (v-&gt;a_count) 是输出列表部分，“+m”表示(v-&gt;a_count)和内存地址关联
//: &quot;ir&quot; (i) 是输入列表部分，“ir” 表示i是和立即数或者寄存器关联
</code></pre><p>有了这些原子操作函数之后 ，前面场景中的代码就变成下面这样了：无论有没有中断，或者什么时间来中断，都不会出错。</p><pre><code>atomic_t a = {0};
void interrupt_handle()
{
    atomic_inc(&amp;a);
}
void thread_func()
{
    atomic_inc(&amp;a);
}
</code></pre><p>好，说完了原子操作，我们再看看怎么用中断控制的思路解决数据并发访问的问题。</p><h2>方法二：中断控制  搞定复杂变量</h2><p>中断是CPU响应外部事件的重要机制，时钟、键盘、硬盘等IO设备都是通过发出中断来请求CPU执行相关操作的（即执行相应的中断处理代码），比如下一个时钟到来、用户按下了键盘上的某个按键、硬盘已经准备好了数据。</p><p>但是中断处理代码中如果操作了其它代码的数据，这就需要相应的控制机制了，这样才能保证在操作数据过程中不发生中断。</p><p>你或许在想，可以用原子操作啊？不过，<strong>原子操作只适合于单体变量</strong>，如整数。操作系统的数据结构有的可能有几百字节大小，其中可能包含多种不同的基本数据类型。这显然用原子操作无法解决。</p><p>下面，我们就要写代码实现关闭开启、中断了，x86 CPU上关闭、开启中断有专门的指令，即cli、sti指令，它们主要是对CPU的eflags寄存器的<strong>IF位</strong>（第9位）进行清除和设置，CPU正是通过此位来决定是否响应中断信号。这两条指令只能Ring0权限才能执行，代码如下。</p><pre><code>//关闭中断
void hal_cli()
{
    __asm__ __volatile__(&quot;cli&quot;: : :&quot;memory&quot;);
}
//开启中断
void hal_sti()
{
    __asm__ __volatile__(&quot;sti&quot;: : :&quot;memory&quot;);
}
//使用场景
void foo()
{
    hal_cli();
    //操作数据……
    hal_sti();
}
void bar()
{
    hal_cli();
    //操作数据……
    hal_sti();
}
</code></pre><p>你可以自己思考一下，前面这段代码效果如何？</p><p>它看似完美地解决了问题，其实有重大缺陷，hal_cli()，hal_sti()，<strong>无法嵌套使用</strong>，看一个例子你就明白了，代码如下。</p><pre><code>void foo()
{
    hal_cli();
    //操作数据第一步……
    hal_sti();
}
void bar()
{
    hal_cli();
    foo();
    //操作数据第二步……
    hal_sti();
}
</code></pre><p>上面代码的关键问题在bar函数在关中断下调用了foo函数，foo函数中先关掉中断，处理好数据然后开启中断，回到bar函数中，bar函数还天真地以为中断是关闭的，接着处理数据，以为不会被中断抢占。</p><p>那么怎么解决上面的问题呢？我们只要修改一下开启、关闭中断的函数就行了。</p><p>我们可以这样操作：在关闭中断函数中先保存eflags寄存器，然后执行cli指令，在开启中断函数中直接恢复之前保存的eflags寄存器就行了，具体代码如下。</p><pre><code>typedef u32_t cpuflg_t;
static inline void hal_save_flags_cli(cpuflg_t* flags)
{
     __asm__ __volatile__(
            &quot;pushfl \t\n&quot; //把eflags寄存器压入当前栈顶
            &quot;cli    \t\n&quot; //关闭中断
            &quot;popl %0 \t\n&quot;//把当前栈顶弹出到flags为地址的内存中        
            : &quot;=m&quot;(*flags)
            :
            : &quot;memory&quot;
          );
}
static inline void hal_restore_flags_sti(cpuflg_t* flags)
{
    __asm__ __volatile__(
              &quot;pushl %0 \t\n&quot;//把flags为地址处的值寄存器压入当前栈顶
              &quot;popfl \t\n&quot;   //把当前栈顶弹出到flags寄存器中
              :
              : &quot;m&quot;(*flags)
              : &quot;memory&quot;
              );
}
</code></pre><p>从上面的代码中不难发现，硬件工程师早就想到了如何解决在嵌套函数中关闭、开启中断的问题：pushfl指令把eflags寄存器压入当前栈顶，popfl把当前栈顶的数据弹出到eflags寄存器中。</p><p>hal_restore_flags_sti()函数的执行，是否开启中断完全取决于上一次eflags寄存器中的值，并且popfl指令只会影响eflags寄存器中的IF位。这样，无论函数嵌套调用多少层都没有问题。</p><h2>方法三：自旋锁 协调多核心CPU</h2><p>前面说的控制中断，看似解决了问题，那是因为以前是单CPU，同一时刻只有一条代码执行流，除了中断会中止当前代码执行流，转而运行另一条代码执行流（中断处理程序），再无其它代码执行流。这种情况下只要控制了中断，就能安全地操作全局数据。</p><p>但是我们都知道，现在情况发生了改变，CPU变成了多核心，或者主板上安装了多颗CPU，同一时刻下系统中存在多条代码执行流，控制中断只能控制本地CPU的中断，无法控制其它CPU核心的中断。</p><p>所以，原先通过控制中断来维护全局数据安全的方案失效了，这就需要全新的机制来处理这样的情况，于是就轮到自旋锁登场了。</p><p>我们先看看自旋锁的原理，它是这样的：首先读取锁变量，判断其值是否已经加锁，如果未加锁则执行加锁，然后返回，表示加锁成功；如果已经加锁了，就要返回第一步继续执行后续步骤，因而得名自旋锁。为了让你更好理解，下面来画一个图描述这个算法。</p><p><img src="https://static001.geekbang.org/resource/image/61/88/619c27c6400344db2310fb82ce8d5788.jpg" alt="" title="自旋锁原理示意图"></p><p>这个算法看似很好，但是想要正确执行它，就<strong>必须保证读取锁变量和判断并加锁的操作是原子执行的。</strong>否则，CPU0在读取了锁变量之后，CPU1读取锁变量判断未加锁执行加锁，然后CPU0也判断未加锁执行加锁，这时就会发现两个CPU都加锁成功，因此这个算法出错了。</p><p>怎么解决这个问题呢？这就要找硬件要解决方案了，x86 CPU给我们提供了一个原子交换指令，xchg，它可以让寄存器里的一个值跟内存空间中的一个值做交换。例如，让eax=memlock，memlock=eax这个动作是原子的，不受其它CPU干扰。</p><p>下面我们就去实现自旋锁，代码如下所示。</p><pre><code>//自旋锁结构
typedef struct
{
     volatile u32_t lock;//volatile可以防止编译器优化，保证其它代码始终从内存加载lock变量的值 
} spinlock_t;
//锁初始化函数
static inline void x86_spin_lock_init(spinlock_t * lock)
{
     lock-&gt;lock = 0;//锁值初始化为0是未加锁状态
}
//加锁函数
static inline void x86_spin_lock(spinlock_t * lock)
{
    __asm__ __volatile__ (
    &quot;1: \n&quot;
    &quot;lock; xchg  %0, %1 \n&quot;//把值为1的寄存器和lock内存中的值进行交换
    &quot;cmpl   $0, %0 \n&quot; //用0和交换回来的值进行比较
    &quot;jnz    2f \n&quot;  //不等于0则跳转后面2标号处运行
    &quot;jmp 3f \n&quot;     //若等于0则跳转后面3标号处返回
    &quot;2:         \n&quot; 
    &quot;cmpl   $0, %1  \n&quot;//用0和lock内存中的值进行比较
    &quot;jne    2b      \n&quot;//若不等于0则跳转到前面2标号处运行继续比较  
    &quot;jmp    1b      \n&quot;//若等于0则跳转到前面1标号处运行，交换并加锁
    &quot;3:  \n&quot;     :
    : &quot;r&quot;(1), &quot;m&quot;(*lock));
}
//解锁函数
static inline void x86_spin_unlock(spinlock_t * lock)
{
    __asm__ __volatile__(
    &quot;movl   $0, %0\n&quot;//解锁把lock内存中的值设为0就行
    :
    : &quot;m&quot;(*lock));
}
</code></pre><p>上述代码的中注释已经很清楚了，关键点在于xchg指令，xchg %0, %1 。</p><p>其中，%0对应 "r"(1)，表示由编译器自动分配一个通用寄存器，并填入值1，例如mov eax，1。而%1对应"m"(*lock)，表示lock是内存地址。把1和内存中的值进行交换，若内存中是1，则不会影响；因为本身写入就是1，若内存中是0，一交换，内存中就变成了1，即加锁成功。</p><p>自旋锁依然有中断嵌套的问题，也就是说，在使用自旋锁的时候我们仍然要注意中断。</p><p>在中断处理程序访问某个自旋锁保护的某个资源时，依然有问题，所以我们要写的自旋锁函数必须适应这样的中断环境，也就是说，它需要在处理中断的过程中也能使用，如下所示。</p><pre><code>static inline void x86_spin_lock_disable_irq(spinlock_t * lock,cpuflg_t* flags)
{
    __asm__ __volatile__(
    &quot;pushfq                 \n\t&quot;
    &quot;cli                    \n\t&quot;
    &quot;popq %0                \n\t&quot;
    &quot;1:         \n\t&quot;
    &quot;lock; xchg  %1, %2 \n\t&quot;
    &quot;cmpl   $0,%1       \n\t&quot;
    &quot;jnz    2f      \n\t&quot;
    &quot;jmp    3f      \n&quot;  
    &quot;2:         \n\t&quot;
    &quot;cmpl   $0,%2       \n\t&quot; 
    &quot;jne    2b      \n\t&quot;
    &quot;jmp    1b      \n\t&quot;
    &quot;3:     \n&quot;     
     :&quot;=m&quot;(*flags)
    : &quot;r&quot;(1), &quot;m&quot;(*lock));
}
static inline void x86_spin_unlock_enabled_irq(spinlock_t* lock,cpuflg_t* flags)
{
    __asm__ __volatile__(
    &quot;movl   $0, %0\n\t&quot;
    &quot;pushq %1 \n\t&quot;
    &quot;popfq \n\t&quot;
    :
    : &quot;m&quot;(*lock), &quot;m&quot;(*flags));
}
</code></pre><p>以上代码实现了关中断下获取自旋锁，以及恢复中断状态释放自旋锁。在中断环境下也完美地解决了问题。</p><h2>方法四：信号量  CPU时间管理大师</h2><p>无论是原子操作，还是自旋锁，都不适合长时间等待的情况，因为有很多资源（数据）它有一定的时间性，你想去获取它，CPU并不能立即返回给你，而是要等待一段时间，才能把数据返回给你。这种情况，你用自旋锁来同步访问这种资源，你会发现这是对CPU时间的巨大浪费。</p><p>下面我们看看另一种同步机制，既能对资源数据进行保护（同一时刻只有一个代码执行流访问），又能在资源无法满足的情况下，让CPU可以执行其它任务。</p><p>如果你翻过操作系统的理论书，应该对信号量这个词并不陌生。信号量是1965年荷兰学者Edsger Dijkstra提出的，是一种用于资源互斥或者进程间同步的机制。这里我们就来看看如何实现这一机制。</p><p>你不妨想象这样一个情境：微信等待你从键盘上的输入信息，然后把这个信息发送出去。</p><p>这个功能我们怎么实现呢？下面我们就来说说实现它的一般方法，当然具体实现中可能不同，但是原理是相通的，具体如下。</p><p>1.一块内存，相当于缓冲区，用于保存键盘的按键码。</p><p>2.需要一套控制机制，比如微信读取这个缓冲区，而该缓冲区为空时怎么处理；该缓冲区中有了按键码，却没有代码执行流来读取，又该怎么处理。</p><p>我们期望是这样的，一共有三点。</p><p>1.当微信获取键盘输入信息时，发现键盘缓冲区中是空的，就进入等待状态。</p><p>2.同一时刻，只能有一个代码执行流操作键盘缓冲区。</p><p>3.当用户按下键盘时，我们有能力把按键码写入缓冲区中，并且能看一看微信或者其它程序是否在等待该缓冲区，如果是就重新激活微信和其它的程序，让它们重新竞争读取键盘缓冲区，如果竞争失败依然进入等待状态。</p><p>其实以上所述无非是三个问题：<strong>等待、互斥、唤醒（即重新激活等待的代码执行流）。</strong></p><p>这就需要一种全新的数据结构来解决这些问题。根据上面的问题，这个数据结构至少需要一个变量来表示互斥，比如大于0则代码执行流可以继续运行，等于0则让代码执行流进入等待状态。还需要一个等待链，用于保存等待的代码执行流。</p><p>这个数据结构的实现代码如下所示。</p><pre><code>#define SEM_FLG_MUTEX 0
#define SEM_FLG_MULTI 1
#define SEM_MUTEX_ONE_LOCK 1
#define SEM_MULTI_LOCK 0
//等待链数据结构，用于挂载等待代码执行流（线程）的结构，里面有用于挂载代码执行流的链表和计数器变量，这里我们先不深入研究这个数据结构。
typedef struct s_KWLST
{   
    spinlock_t wl_lock;
    uint_t   wl_tdnr;
    list_h_t wl_list;
}kwlst_t;
//信号量数据结构
typedef struct s_SEM
{
    spinlock_t sem_lock;//维护sem_t自身数据的自旋锁
    uint_t sem_flg;//信号量相关的标志
    sint_t sem_count;//信号量计数值
    kwlst_t sem_waitlst;//用于挂载等待代码执行流（线程）结构
}sem_t;
</code></pre><p>搞懂了信号量的结构，我们再来看看信号量的一般用法，注意信号量在使用之前需要<strong>先进行初始化</strong>。这里假定信号量数据结构中的sem_count初始化为1，sem_waitlst等待链初始化为空。</p><p>使用信号量的步骤，我已经给你列好了。</p><p><strong>第一步，获取信号量。</strong></p><p>1.首先对用于保护信号量自身的自旋锁sem_lock进行加锁。<br>
2.对信号值sem_count执行“减1”操作，并检查其值是否小于0。<br>
3.上步中检查sem_count如果小于0，就让进程进入等待状态并且将其挂入sem_waitlst中，然后调度其它进程运行。否则表示获取信号量成功。当然最后别忘了对自旋锁sem_lock进行解锁。</p><p><strong>第二步，代码执行流开始执行相关操作，例如读取键盘缓冲区。</strong></p><p><strong>第三步，释放信号量。</strong></p><p>1.首先对用于保护信号量自身的自旋锁sem_lock进行加锁。<br>
2.对信号值sem_count执行“加1”操作，并检查其值是否大于0。<br>
3.上步中检查sem_count值如果大于0，就执行唤醒sem_waitlst中进程的操作，并且需要调度进程时就执行进程调度操作，不管sem_count是否大于0（通常会大于0）都标记信号量释放成功。当然最后别忘了对自旋锁sem_lock进行解锁。</p><p>这里我给你额外分享一个小技巧，<strong>写代码之前我们常常需要先想清楚算法步骤，建议你像我这样分条列出，因为串联很容易含糊其辞，不利于后面顺畅编码。</strong></p><p>好，下面我们来看看实现上述这些功能的代码，按照理论书籍上说，信号量有两个操作：down，up，代码如下。</p><pre><code>//获取信号量
void krlsem_down(sem_t* sem)
{
    cpuflg_t cpufg;
start_step:    
    krlspinlock_cli(&amp;sem-&gt;sem_lock,&amp;cpufg);
    if(sem-&gt;sem_count&lt;1)
    {//如果信号量值小于1,则让代码执行流（线程）睡眠
        krlwlst_wait(&amp;sem-&gt;sem_waitlst);
        krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);
        krlschedul();//切换代码执行流，下次恢复执行时依然从下一行开始执行，所以要goto开始处重新获取信号量
        goto start_step; 
    }
    sem-&gt;sem_count--;//信号量值减1,表示成功获取信号量
    krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);
    return;
}
//释放信号量
void krlsem_up(sem_t* sem)
{
    cpuflg_t cpufg;
    krlspinlock_cli(&amp;sem-&gt;sem_lock,&amp;cpufg);
    sem-&gt;sem_count++;//释放信号量
    if(sem-&gt;sem_count&lt;1)
    {//如果小于1,则说数据结构出错了，挂起系统
        krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);
        hal_sysdie(&quot;sem up err&quot;);
    }
    //唤醒该信号量上所有等待的代码执行流（线程）
    krlwlst_allup(&amp;sem-&gt;sem_waitlst);
    krlspinunlock_sti(&amp;sem-&gt;sem_lock,&amp;cpufg);
    krlsched_set_schedflgs();
    return;
}
</code></pre><p>上述代码中的krlspinlock_cli，krlspinunlock_sti两个函数，只是对前面自旋锁函数的一个<strong>封装</strong>，krlschedul、krlwlst_wait、krlwlst_allup、krlsched_set_schedflgs这几个函数会在进程相关课程进行探讨。</p><h2>重点回顾</h2><p>又到了这节课结束的时候，我们回顾一下今天都讲了什么。我把这节课的内容为你梳理一下，要点如下。</p><p>1.原子变量，在只有<strong>单个变量全局数据</strong>的情况下，这种变量非常实用，如全局计数器、状态标志变量等。我们利用了CPU的原子指令实现了一组操作原子变量的函数。</p><p>2.中断的控制。当要操作的数据很多的情况下，用原子变量就不适合了。但是我们发现在单核心的CPU，同一时刻只有一个代码执行流，除了响应中断导致代码执行流切换，不会有其它条件会干扰全局数据的操作，所以我们只要在操作全局数据时关闭或者开启中断就行了，为此我们开发了控制中断的函数。</p><p>3.自旋锁。由于多核心的CPU出现，控制中断已经失效了，因为<strong>系统中同时有多个代码执行流</strong>，为了解决这个问题，我们开发了自旋锁，自旋锁要么一下子获取锁，要么循环等待最终获取锁。</p><p>4.信号量。如果长时间等待后才能获取数据，在这样的情况下，前面中断控制和自旋锁都不能很好地解决，于是我们开发了信号量。信号量由一套数据结构和函数组成，它能使获取数据的代码执行流进入睡眠，然后在相关条件满足时被唤醒，这样就能让CPU能有时间处理其它任务。所以信号量同时解决了三个问题：<strong>等待、互斥、唤醒。</strong></p><h2>思考题</h2><p>请用代码展示一下自旋锁或者信号量，可能的使用形式是什么样的？</p><p>期待你在留言区的分享，也欢迎你把这节课的内容分享给身边的朋友，跟他一起学习交流。</p><p>我是LMOS，我们下节课见！</p><h2>精选留言：</h2>
        <ul>
        
<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            pedro  2021-05-26 08:46:57
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            今天的专栏可谓是精彩至极！<br>锁是解决并发同步问题的关键，从本文来看，锁有两个核心点，一个是原子操作，另一个则是中断；<br>通过原子操作来实现临界区标志位的改变，关闭中断来避免CPU中途离开导致数据同步失败问题。<br>自旋锁(spinlock)是锁的最小原型，其它锁都是以它为基础来实现的，自旋锁的实现也颇为简单，只需一个简单的原子标志位就可以实现了，当然还要妥善管理中断。<br>在 xv6 中，对锁的实现只有两种，一种是刚才提到的 spinlock，而另外一种则是 sleeplock，spinlock 不会让出 CPU 执行权，而 sleeplock 则是在 spinlock 的基础上，增加 sleep 功能，即如果一个执行体(线程或者进程)加锁失败，就会进入休眠状态，让出 CPU 执行权，让其它的任务也能得以执行。<br>本文中的信号量(sem)也是 sleeplock 的一种，sem 的实现更为精致，通过等待队列来记录加锁失败的执行体，并后续通过一定的策略来选择唤醒，这也是很多编程语言中信号量的实现方式。<br>当然不同的语言会有不同的优化，比如 go 的 Mutex 是非公平的唤醒机制，但是针对非公平的场景，又设有饥饿补偿，总之本文中实现的 sem 几乎是任何信号量（锁）实现的基础蓝本。<br><br>对于思考题答案，这里就顺便贴一下吧，如果有啥问题，欢迎大家交流指正：<br>  spinlock_t lock;<br>  x86_spin_lock_init(&amp;lock);<br>  &#47;&#47; 加锁，如果加锁成功则进入下面代码执行<br>  &#47;&#47; 否则，一直自旋，不断检查 lock 值为否为 0<br>  x86_spin_lock_disable_irq(&amp;lock);<br>  &#47;&#47; 处理一些数据同步、协同场景<br>  doing_something();<br>  &#47;&#47; 解锁<br>  x86_spin_unlock_enabled_irq(&amp;lock);<br><br><br>  sem_t sem;<br>  x86_sem_init(&amp;sem);<br>  &#47;&#47; 加锁，减少信号量，如果信号量已经为 0<br>  &#47;&#47; 则加锁失败，当前线程会改变为 sleeping 状态<br>  &#47;&#47; 并让出 CPU 执行权<br>  krlsem_down(&amp;sem);<br>  &#47;&#47; 处理一些数据同步、协同场景<br>  doing_something();<br>  &#47;&#47; 解锁，增加信号量，唤醒等待队列中的其它线程（若存在）<br>  krlsem_up(&amp;sem);<br> [22赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2021-05-26 21:56:55</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">我非常喜欢你这样的读者，你总是能抓住问题的本质，继续保持，为你点赞</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            嗣树  2021-05-26 15:48:41
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            记录下我学习本节内容的一些思考：<br>1. 学习到这里还没有引入抢占这个概念，所以讨论环境中默认进程上下文不会发生抢占，同样也没有进程切换这些东西。<br>其实讲进程上下文也不对，我们都还没有引入这些东西，暂且凑合这么用吧。<br><br>2. 首先讨论了单 cpu 情况下，保证数据一致性的方式，这一时期我们主要防中断：<br>	- 对于单个变量我们实现了原子变量（由硬件提供支持），中断是不能打断这个操作的<br>	- 对于复杂变量的操作，这个时候中断可以乱入了，我们通过关中断来保证单 cpu 下这些数据的正确<br><br>3. 到了多 cpu 时代，不止有中断这个小三，还有隔壁老王（其他核），关中断已经不管用了，<br>为了数据的一致需要大家在操作前都走自旋流程，自旋需要新的原子操作支持（xchg），到此我们解决了老王带来的问题。<br><br>4. 但是我们还需要面对中断的问题，自旋锁的实现是带条件的死循环，这也引入了一个问题：死锁。<br>cpu 间的互相抢锁最多抢不到等一会，但是 cpu 和本地中断之间就不同了。<br><br>当本 cpu 占有了锁，此时打来中断，假如中断中也要抢这把锁，那他抢不到嘛，只好死给你看咯。<br>而中断也可以嵌套，这种情况也可能死。所以对自旋锁升级，添加了关中断的操作。<br><br>5. 最后老师介绍了信号量，这里其实已经带入了调度的概念。<br><br>6. 最后在思考一下抢占和中断优先级带来的问题，其实也还是死锁的问题。<br>上面我们设想了两种死锁的情况。我们泛化一下，其实中断可以看作比普通进程优先级更高的进程，<br>只要是构成这种 低级持锁，高级来抢 的局面都可能死锁。而抢占和中断优先级创造了更多的阶级，<br>也就产生了更多的可能。所以 Linux 中自旋锁的实现第一步是关抢占。<br><br>错误或疏漏的地方还请指正，抱拳了老铁。 [7赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2021-05-26 21:42:38</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">你好，你学的很认真，学的很通透，总结很到位</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            neohope  2021-05-26 14:41:27
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            当前版本还有几个问题还没有解决，希望后面课程有进一步详解：<br>1、跨用户进程时，如何共享内核的同一个锁或信号量<br>2、没有提供锁的可重入不可重入的限制<br>3、锁自旋时不会让渡CPU时间<br>4、暂时没有提供公平锁算法<br>5、暂时没有提供乐观锁算法<br><br>基于本节，其实大家可以尝试一下：<br>1、信号量如何提供最大资源数限制<br>2、信号量如何提供扣除多个资源的支持<br>3、如何实现互斥量这一类数据结构呢<br>4、如何实现读写锁这一类数据结构呢<br><br>锁一般用来做线程间或进程间的互斥操作<br>信号量一般用来做线程间或进程间资源同步操作，比如资源的占用和释放等 [7赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2021-05-26 21:46:04</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">是的，我们后面会有介绍 的 </div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            Freddy  2021-05-28 16:50:48
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            本节是关于共享数据的并发修改问题，总结了不同场景下的使用方式：<br>当共享数据是单体变量时，可以尝试使用原子操作指令；<br>当共享数据是复杂的数据结构时：<br>当是单CPU环境时，只有中断和业务进程两个代码操作流，此时我们可以手动控制CPU中断关闭&#47;开启，要注意解决CPU中断关闭&#47;开启的嵌套调用问题；<br>当是多CPU环境时，就不能同时控制多个CPU的中断了，此时我们用到了自旋锁；多个CPU进程竞争自旋锁，成功加锁的进程，可以执行自己的业务流程；这里要注意的是要保证自旋锁流程中的读取锁变量和判断并加锁的操作是原子执行的；<br>在多CPU环境时，没有获取自旋锁的CPU，就会一直在循环读取锁变量和判断是否加锁的流程当中，浪费了CPU资源，为了解决这个问题，引入了信号量；<br>首先，各个进程会去竞争信号量；<br>没有获取信号量的进程放入等待队列，这样该进程所在的CPU就可以去执行其他业务进程了；<br>获取信号量的进程执行完后，会释放信号量后，同时会去唤醒在等待队列中的进程，这样等待的进程就会再次去竞争信号量；<br>思考：<br>1.那一个进程中的多个线程并发修改共享数据的模型，应该也是同样的道理吧？？<br>2.锁，应该是操作的前提条件，有了锁才能去执行业务代码；<br>但对原子操作来说，好像是加锁和业务操作一起执行了。<br> 
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            noisyes  2021-05-27 23:42:24
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            真的是把锁的前生今世讲得明明白白，让我有种豁然开朗的感觉！可能到最后可能无法独自实现一个操作系统，但是真的能从底层的角度重新认识操作系统！ [1赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">编辑回复2021-05-28 10:56:37</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">小编回复，很高兴这个专栏能够帮到你，后面更精彩，敬请期待。还有，只要有兴趣，跟着课程走，是可以跑起来操作系统的，别慌。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            惜心（伟祺）  2021-05-27 14:49:23
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            这个问题抽象下就是在如何在并行执行中做到串联有序<br>解决思路就两个：<br>1.在结果端（确保内存一致）<br>2.在过程端（确保cpu计算中不被打断）<br>原子性就是确保内存一致，但是因为cpu计算需要时间所以只能保证一个单位的绝对一致<br>至于锁、信号都是在对上面两种思路的组合，妙的是会出现跨代组合来实现更多样化的应用<br>老师从根本上分析问题，由简到繁，一下抓住根本和牛逼<br>其实操作系统就是对简单的功能的组合重复实现无限复杂操作<br>这种思路和软件开发是一致的，用一种语言API，各种的组合重复利用时间空间的重复解决各种复杂问题 
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            黎  2021-05-26 09:10:07
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            原子变量，中断，自旋锁，信号量，层层递进，都是在前一个技术的某些场景无法满足的情况下，更高级复杂的解决方案，当然也是基于前面的基础的封装 [5赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2021-05-26 21:51:58</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">你这角度也很透彻，很好</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            Fan  2021-05-26 00:48:35
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            好 [2赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">编辑回复2021-05-26 10:15:24</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">谢谢啦！欢迎分享你的收获，对梳理自己的思路有帮助，同时也能帮到其他人。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            舞铲阶级  2021-05-26 22:33:54
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            一开始，从单个变量可能由于中断，而产生达不到预期结果的情况，可以通过硬件层面的原子操作，来解决相应问题；但硬件层面的的原子操作没办法适应多种多样的数据结构，这个时候就需要对中断来进行处理，保证数据处理过程中的“原子性”，对于嵌套中断的问题采用栈来保存对应的标志寄存器内容，用于还原来解决嵌套问题；但多核CPU可以绕过单个CPU的中断从而影响数据处理的“原子性”（个人理解希望老师指点），这时候通过硬件提供一个变量来形成自旋锁，保证处理的“原子性”，但是仍会由于嵌套中断从而导致占有自旋锁后进入死循环，因此引入关中断自旋锁来保证“原子性”；最后以上三种情况都不支持长时间等待情况，因此引入了信号量，注意对信号量的操作时要使用自旋锁来保证其“原子性”，如有不对希望大家指正。 [1赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2021-05-27 13:38:05</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">你好，正确的</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            的是  2021-05-28 15:20:00
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            东哥，到本45讲之后是否有完整的这个操作系统的源码？这样才有实操感。 
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            ！null  2021-05-28 08:10:42
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            &quot;lock; xchg  %1, %2 \n\t&quot;<br>lock也是汇编指令吗？咋用的？ 
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            陈超  2021-05-27 22:32:30
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            锁的防嵌套处理，就是递归锁的实现原理吗？ 
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            老男孩  2021-05-27 11:44:05
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            java可以会把锁的状态值放到redis中，然后让redis执行lua脚本来保证执行的原子性。<br>加锁：  if redis.call(&#39;setNx&#39;,KEYS[1],ARGV[1]) == 1 <br>        then if redis.call(&#39;get&#39;,KEYS[1]) == ARGV[1] <br>		then return redis.call(&#39;expire&#39;,KEYS[1],ARGV[2])<br>		else return 0 end else return 0 end<br>		<br>释放锁：if redis.call(&#39;get&#39;, KEYS[1]) == ARGV[1] <br>        then return redis.call(&#39;del&#39;, KEYS[1]) <br>		else return 0 end<br>		<br>用一个while循环，退出条件是加锁成功。在循环体中把当前线程挂起，并放到一个等待列表中。<br>获得锁的执行流，最后释放锁，并唤醒等待的线程去竞争锁。<br><br>学到这里，我算是明白为什么行业里边有一个鄙视链 ：搞汇编-&gt;搞C的-&gt;搞C++-&gt;搞Java的,看来还是有些道理的。<br>java有很多类库，工具包，第三方组件来帮助程序员解决偏底层的技术实现，让java程序员更专注业务的开发，也就是java们经常自嘲的堆代码搬砖。<br>身为一个java老码农，我觉得我也不用纠结了。跟着老师还有大神们认真的学一下，目标不能搞太高，学完这门课至少能从我不知道我不知道变成我知道我不知道就可以了。如果有意外惊喜，那就更好了。这就是所谓的佛系学习法吧。哈哈！ 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2021-05-27 13:25:07</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6"> 是的，完全不用有心理负担，慢慢学，鄙视链完全是心理作用 ，我有时还要写JS、HTML、CSS呢 </div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            陈超  2021-05-27 11:08:42
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            请问下老师，单核情况下是不是无法使用自旋锁？因为自旋锁不让出cpu时间片，单核情况下会死循环？ 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2021-05-27 13:26:30</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">你好，单核CPU下 会直接加锁成功，只要你不重复加锁</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            WGJ  2021-05-27 02:51:44
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            这里的自旋锁应该会有次数的吧，不可能一直在自旋，像go里面的信号量，默认自旋4次，如果还是锁定状态，那么才会休眠 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2021-05-27 13:32:41</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">你好，我们代码中的锁是最简单的形式，方便理解原理的</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            Geek_1d6510  2021-05-26 22:20:18
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            努力加油，收获满满 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">编辑回复2021-05-26 23:32:37</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">加油呀！</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            AmazingYu  2021-05-26 20:16:33
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            如果所有核上的线程同时间开启了禁止中断，那这个系统是不是就卡死了？ 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2021-05-26 21:14:11</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">你好，这还要看禁止中断之后做什么 这不一定就卡死的 </div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            AmazingYu  2021-05-26 19:39:08
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            茅塞顿开 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">编辑回复2021-05-26 19:44:19</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">很开心你能有收获，搞懂的内容欢迎记录和分享哦！</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            宏典  2021-05-26 17:48:41
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            加上 lock 前缀的 addl、subl、incl、decl 指令都是原子操作，lock 前缀表示锁定总线。<br><br>为何加上lock锁住总线就可以保证原子性？？ 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2021-05-26 21:19:13</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">因为多核心cpu会同时相同的指令 同时访问内存 lock 就要避免这种情况的发生 </div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            送过快递的码农  2021-05-26 16:09:08
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            硬着头皮看了一遍。。。 我发现一个核心的问题不懂，就是关于中断。我只知道硬中断，软中断。但是我不清楚 老师调用了开启中断的服务和关闭中断的服务到底是有什么作用。如果我们在内核里面写一个函数，关闭中断，然后无限自旋，是不是这个任务就没法打断了，cpu是不是就被无限抢占了。但是如果我开了中断，就能打断了么，这也CPU 也能执行别的任务。<br>还有就是今天总体来说讲了4个知识点，原子变量，中断控制，自旋锁，信号量 这4个为啥我没找到一个贯穿这个的点，可能是我没读明白，脑子里乱的有点麻 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2021-05-26 21:24:13</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">是的，你或许看到后面的处理中断 就明白了 慢慢来</div>
</div>
            
    </div>
</li>
            </ul>
</div>
</body>
</html>