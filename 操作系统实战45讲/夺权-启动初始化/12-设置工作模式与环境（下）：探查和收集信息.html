<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <!--<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>-->
    <title>12-设置工作模式与环境（下）：探查和收集信息</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <style>
        html {
            color: #333;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-rendering: optimizelegibility;
            font-family: Helvetica Neue, PingFang SC, Verdana, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, sans-serif
        }

        html.borderbox *,
        html.borderbox :after,
        html.borderbox :before {
            box-sizing: border-box
        }

        article,
        aside,
        blockquote,
        body,
        button,
        code,
        dd,
        details,
        dl,
        dt,
        fieldset,
        figcaption,
        figure,
        footer,
        form,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        header,
        hr,
        input,
        legend,
        li,
        menu,
        nav,
        ol,
        p,
        pre,
        section,
        td,
        textarea,
        th,
        ul {
            margin: 0;
            padding: 0
        }

        article,
        aside,
        details,
        figcaption,
        figure,
        footer,
        header,
        menu,
        nav,
        section {
            display: block
        }

        audio,
        canvas,
        video {
            display: inline-block
        }

        body,
        button,
        input,
        select,
        textarea {
            font: 300 1em/1.8 PingFang SC, Lantinghei SC, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, Helvetica, sans-serif
        }

        button::-moz-focus-inner,
        input::-moz-focus-inner {
            padding: 0;
            border: 0
        }

        table {
            border-collapse: collapse;
            border-spacing: 0
        }

        fieldset,
        img {
            border: 0
        }

        blockquote {
            position: relative;
            color: #999;
            font-weight: 400;
            border-left: 1px solid #1abc9c;
            padding-left: 1em;
            margin: 1em 3em 1em 2em
        }

        @media only screen and (max-width: 640px) {
            blockquote {
                margin: 1em 0
            }
        }

        abbr,
        acronym {
            border-bottom: 1px dotted;
            font-variant: normal
        }

        abbr {
            cursor: help
        }

        del {
            text-decoration: line-through
        }

        address,
        caption,
        cite,
        code,
        dfn,
        em,
        th,
        var {
            font-style: normal;
            font-weight: 400
        }

        ol,
        ul {
            list-style: none
        }

        caption,
        th {
            text-align: left
        }

        q:after,
        q:before {
            content: ""
        }

        sub,
        sup {
            font-size: 75%;
            line-height: 0;
            position: relative
        }

        :root sub,
        :root sup {
            vertical-align: baseline
        }

        sup {
            top: -.5em
        }

        sub {
            bottom: -.25em
        }

        a {
            color: #1abc9c
        }

        a:hover {
            text-decoration: underline
        }

        .typo a {
            border-bottom: 1px solid #1abc9c
        }

        .typo a:hover {
            border-bottom-color: #555;
            color: #555
        }

        .typo a:hover,
        a,
        ins {
            text-decoration: none
        }

        .typo-u,
        u {
            text-decoration: underline
        }

        mark {
            background: #fffdd1;
            border-bottom: 1px solid #ffedce;
            padding: 2px;
            margin: 0 5px
        }

        code,
        pre,
        pre tt {
            font-family: Courier, Courier New, monospace
        }

        pre {
            background: hsla(0, 0%, 97%, .7);
            border: 1px solid #ddd;
            padding: 1em 1.5em;
            display: block;
            -webkit-overflow-scrolling: touch
        }

        hr {
            border: none;
            border-bottom: 1px solid #cfcfcf;
            margin-bottom: .8em;
            height: 10px
        }

        .typo-small,
        figcaption,
        small {
            font-size: .9em;
            color: #888
        }

        b,
        strong {
            font-weight: 700;
            color: #000
        }

        [draggable] {
            cursor: move
        }

        .clearfix:after,
        .clearfix:before {
            content: "";
            display: table
        }

        .clearfix:after {
            clear: both
        }

        .clearfix {
            zoom: 1
        }

        .textwrap,
        .textwrap td,
        .textwrap th {
            word-wrap: break-word;
            word-break: break-all
        }

        .textwrap-table {
            table-layout: fixed
        }

        .serif {
            font-family: Palatino, Optima, Georgia, serif
        }

        .typo-dl,
        .typo-form,
        .typo-hr,
        .typo-ol,
        .typo-p,
        .typo-pre,
        .typo-table,
        .typo-ul,
        .typo dl,
        .typo form,
        .typo hr,
        .typo ol,
        .typo p,
        .typo pre,
        .typo table,
        .typo ul,
        blockquote {
            margin-bottom: 1rem
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-family: PingFang SC, Helvetica Neue, Verdana, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, sans-serif;
            color: #000;
            line-height: 1.35
        }

        .typo-h1,
        .typo-h2,
        .typo-h3,
        .typo-h4,
        .typo-h5,
        .typo-h6,
        .typo h1,
        .typo h2,
        .typo h3,
        .typo h4,
        .typo h5,
        .typo h6 {
            margin-top: 1.2em;
            margin-bottom: .6em;
            line-height: 1.35
        }

        .typo-h1,
        .typo h1 {
            font-size: 2em
        }

        .typo-h2,
        .typo h2 {
            font-size: 1.8em
        }

        .typo-h3,
        .typo h3 {
            font-size: 1.6em
        }

        .typo-h4,
        .typo h4 {
            font-size: 1.4em
        }

        .typo-h5,
        .typo-h6,
        .typo h5,
        .typo h6 {
            font-size: 1.2em
        }

        .typo-ul,
        .typo ul {
            margin-left: 1.3em;
            list-style: disc
        }

        .typo-ol,
        .typo ol {
            list-style: decimal;
            margin-left: 1.9em
        }

        .typo-ol ol,
        .typo-ol ul,
        .typo-ul ol,
        .typo-ul ul,
        .typo li ol,
        .typo li ul {
            margin-bottom: .8em;
            margin-left: 2em
        }

        .typo-ol ul,
        .typo-ul ul,
        .typo li ul {
            list-style: circle
        }

        .typo-table td,
        .typo-table th,
        .typo table caption,
        .typo table td,
        .typo table th {
            border: 1px solid #ddd;
            padding: .5em 1em;
            color: #666
        }

        .typo-table th,
        .typo table th {
            background: #fbfbfb
        }

        .typo-table thead th,
        .typo table thead th {
            background: hsla(0, 0%, 95%, .7)
        }

        .typo table caption {
            border-bottom: none
        }

        .typo-input,
        .typo-textarea {
            -webkit-appearance: none;
            border-radius: 0
        }

        .typo-em,
        .typo em,
        caption,
        legend {
            color: #000;
            font-weight: inherit
        }

        .typo-em {
            position: relative
        }

        .typo-em:after {
            position: absolute;
            top: .65em;
            left: 0;
            width: 100%;
            overflow: hidden;
            white-space: nowrap;
            content: "\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB"
        }

        .typo img {
            max-width: 100%
        }

        .common-content {
            font-weight: 400;
            color: #353535;
            line-height: 1.75rem;
            white-space: normal;
            word-break: normal;
            font-size: 1rem
        }

        .common-content img {
            display: block;
            max-width: 100%;
            background-color: #eee
        }

        .common-content audio,
        .common-content video {
            width: 100%;
            background-color: #eee
        }

        .common-content center,
        .common-content font {
            margin-top: 1rem;
            display: inline-block
        }

        .common-content center {
            width: 100%
        }

        .common-content pre {
            margin-top: 1rem;
            padding-left: 0;
            padding-right: 0;
            position: relative;
            overflow: hidden
        }

        .common-content pre code {
            font-size: .8rem;
            font-family: Consolas, Liberation Mono, Menlo, monospace, Courier;
            display: block;
            width: 100%;
            box-sizing: border-box;
            padding-left: 1rem;
            padding-right: 1rem;
            overflow-x: auto
        }

        .common-content hr {
            border: none;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            border-top: 1px solid #f5f5f5;
            height: 1px;
            background: none
        }

        .common-content b,
        .common-content h1,
        .common-content h2,
        .common-content h3,
        .common-content h4,
        .common-content h5,
        .common-content strong {
            font-weight: 700
        }

        .common-content h1,
        .common-content h2 {
            font-size: 1.125rem;
            margin-bottom: .45rem
        }

        .common-content h3,
        .common-content h4,
        .common-content h5 {
            font-size: 1rem;
            margin-bottom: .45rem
        }

        .common-content p {
            font-weight: 400;
            color: #353535;
            margin-top: .15rem
        }

        .common-content .orange {
            color: #ff5a05
        }

        .common-content .reference {
            font-size: 1rem;
            color: #888
        }

        .custom-rich-content h1 {
            margin-top: 0;
            font-weight: 400;
            font-size: 15.25px;
            border-bottom: 1px solid #eee;
            line-height: 2.8
        }

        .custom-rich-content li,
        .custom-rich-content p {
            font-size: 14px;
            color: #888;
            line-height: 1.6
        }

        table.hljs-ln {
            margin-bottom: 0;
            border-spacing: 0;
            border-collapse: collapse
        }

        table.hljs-ln,
        table.hljs-ln tbody,
        table.hljs-ln td,
        table.hljs-ln tr {
            box-sizing: border-box
        }

        table.hljs-ln td {
            padding: 0;
            border: 0
        }

        table.hljs-ln td.hljs-ln-numbers {
            min-width: 15px;
            color: rgba(27, 31, 35, .3);
            text-align: right;
            white-space: nowrap;
            cursor: pointer;
            user-select: none
        }

        table.hljs-ln td.hljs-ln-code,
        table.hljs-ln td.hljs-ln-numbers {
            font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;
            font-size: 12px;
            line-height: 20px;
            vertical-align: top
        }

        table.hljs-ln td.hljs-ln-code {
            position: relative;
            padding-right: 10px;
            padding-left: 10px;
            overflow: visible;
            color: #24292e;
            word-wrap: normal;
            white-space: pre
        }

        video::-webkit-media-controls {
            overflow: hidden !important
        }

        video::-webkit-media-controls-enclosure {
            width: calc(100% + 32px);
            margin-left: auto
        }

        ._29HP61GA_0 {
            max-width:800px;
            margin:0 auto;
            margin-bottom: 20px;
            font-weight: 400;
            color: #353535;
            line-height: 1.76;
            white-space: normal;
            word-break: normal;
            font-size: 17px;
            -webkit-transition: background-color .3s ease;
            transition: background-color .3s ease
        }

        ._29HP61GA_0 .MathJax_Display {
            overflow: auto
        }

        ._29HP61GA_0 .poster {
            position: fixed;
            left: -10000px;
            top: -10000px;
            overflow: hidden;
            padding: 1rem;
            background: #ececec
        }

        ._29HP61GA_0 .richcontent-pre-copy {
            font-size: 13px;
            color: #888;
            position: absolute;
            right: 1em;
            top: .5em;
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none
        }

        ._29HP61GA_0 .richcontent-pre-copy .iconfont {
            font-size: 12px;
            margin-right: .2em
        }

        ._29HP61GA_0 a {
            color: #fa8919;
            border-bottom: 1px solid #fa8919
        }

        ._29HP61GA_0 img {
            display: block;
            max-width: 100%;
            position: relative;
            left: 50%;
            -webkit-transform: translateX(-50%);
            transform: translateX(-50%);
            background-color: #eee;
            vertical-align: top;
            border-radius: 0
        }

        ._29HP61GA_0 audio,
        ._29HP61GA_0 video {
            width: 100%;
            background-color: #eee
        }

        ._29HP61GA_0 pre {
            margin-top: 16px;
            padding: 34px 0 0;
            margin-bottom: 30px;
            position: relative;
            border-radius: 6px;
            background: rgba(246, 247, 251, .749);
            border: 0
        }

        ._29HP61GA_0 pre code {
            font-size: 12px;
            font-family: Consolas, Liberation Mono, Menlo, monospace, Courier;
            display: block;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
            margin-left: 16px;
            margin-right: 16px;
            overflow-x: scroll
        }

        ._29HP61GA_0 pre code:after {
            content: "";
            height: 30px;
            width: 100%;
            display: block
        }

        ._29HP61GA_0 hr {
            border: none;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            border-top: 1px solid #f5f5f5;
            height: 1px;
            background: none
        }

        ._29HP61GA_0 h1,
        ._29HP61GA_0 h2,
        ._29HP61GA_0 h3,
        ._29HP61GA_0 h4,
        ._29HP61GA_0 h5 {
            margin-bottom: 20px;
            margin-top: 0;
            font-weight: 700
        }

        ._29HP61GA_0 b,
        ._29HP61GA_0 strong {
            font-weight: 700
        }

        ._29HP61GA_0 h1 {
            font-size: 21px
        }

        ._29HP61GA_0 h2 {
            font-size: 20px
        }

        ._29HP61GA_0 h3 {
            font-size: 19px
        }

        ._29HP61GA_0 h4 {
            font-size: 18px
        }

        ._29HP61GA_0 h5 {
            font-size: 17px
        }

        ._29HP61GA_0 center,
        ._29HP61GA_0 p {
            font-weight: 400;
            color: #353535;
            margin-top: 0;
            margin-bottom: 30px;
            word-break: break-word
        }

        ._29HP61GA_0 center {
            text-align: center
        }

        ._29HP61GA_0 blockquote {
            margin-top: 0;
            margin-bottom: 34px;
            border-left: 3px solid #e8e8e8;
            padding-left: 17px;
            color: #353535
        }

        ._29HP61GA_0 blockquote p {
            margin-top: 0;
            margin-bottom: 0
        }

        ._29HP61GA_0 ol,
        ._29HP61GA_0 ul {
            margin-bottom: 30px
        }

        ._29HP61GA_0 ol p,
        ._29HP61GA_0 ul p {
            margin-top: 0;
            margin-bottom: 0
        }

        ._29HP61GA_0 ol {
            list-style: decimal;
            margin-left: 20px
        }

        ._29HP61GA_0 ul li {
            padding-left: 17px;
            position: relative;
            margin-bottom: 10px
        }

        ._29HP61GA_0 ul li:after {
            content: "";
            height: 6px;
            width: 6px;
            border-radius: 50%;
            background: #353535;
            position: absolute;
            top: 10px;
            left: 0
        }

        ._29HP61GA_0 .orange {
            color: #fa8919
        }

        ._29HP61GA_0 .reference {
            color: #888
        }

        ._29HP61GA_0 .m-right {
            text-align: right
        }

        ._29HP61GA_0 .m-center {
            text-align: center;
            display: block
        }

        ._29HP61GA_0 .m-gray {
            color: #888
        }

        ._29HP61GA_0 .m-small {
            font-size: 15px
        }

        ._29HP61GA_0 table.hljs-ln {
            margin-bottom: 0;
            border-spacing: 0;
            border-collapse: collapse
        }

        ._29HP61GA_0 table.hljs-ln,
        ._29HP61GA_0 table.hljs-ln tbody,
        ._29HP61GA_0 table.hljs-ln td,
        ._29HP61GA_0 table.hljs-ln tr {
            -webkit-box-sizing: border-box;
            box-sizing: border-box
        }

        ._29HP61GA_0 table.hljs-ln td {
            padding: 0;
            border: 0
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-numbers {
            min-width: 15px;
            font-size: 12px;
            color: rgba(27, 31, 35, .3);
            text-align: right;
            white-space: nowrap;
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-code,
        ._29HP61GA_0 table.hljs-ln td.hljs-ln-numbers {
            font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;
            line-height: 20px;
            vertical-align: top
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-code {
            position: relative;
            padding-right: 10px;
            padding-left: 10px;
            overflow: visible;
            font-size: 13px;
            color: #666;
            word-wrap: normal;
            white-space: pre
        }

    </style>
</head>
<body>
<div class="_29HP61GA_0">
<h1>12-设置工作模式与环境（下）：探查和收集信息</h1>
<p>你好，我是LMOS。</p><p>上节课我们动手实现了自己的二级引导器。今天这节课我们将进入二级引导器，完成具体工作的环节。</p><p>在二级引导器中，我们要检查CPU是否支持64位的工作模式、收集内存布局信息，看看是不是合乎我们操作系统的最低运行要求，还要设置操作系统需要的MMU页表、设置显卡模式、释放中文字体文件。</p><p>今天课程的配套代码，你可以点击<a href="https://gitee.com/lmos/cosmos/tree/master/lesson12/Cosmos">这里</a>，自行下载。</p><h2>检查与收集机器信息</h2><p>如果ldrkrl_entry()函数是总裁，那么init_bstartparm()函数则是经理，它负责管理检查CPU模式、收集内存信息，设置内核栈，设置内核字体、建立内核MMU页表数据。</p><p>为了使代码更加清晰，我们并不直接在ldrkrl_entry()函数中搞事情，而是准备在另一个bstartparm.c文件中实现一个init_bstartparm()。</p><p>下面我们就来动手实现它，如下所示。</p><pre><code>//初始化machbstart_t结构体，清0,并设置一个标志
void machbstart_t_init(machbstart_t* initp)
{
    memset(initp,0,sizeof(machbstart_t));
    initp-&gt;mb_migc=MBS_MIGC;
    return;
}
void init_bstartparm()
{
    machbstart_t* mbsp = MBSPADR;//1MB的内存地址
    machbstart_t_init(mbsp);
    return;
}
</code></pre><p>目前我们的经理init_bstartparm()函数只是调用了一个machbstart_t_init()函数，在1MB内存地址处初始化了一个机器信息结构machbstart_t，后面随着干活越来越多，还会调用更多的函数的。</p><h3>检查CPU</h3><!-- [[[read_end]]] --><p>首先要检查我们的CPU，因为它是执行程序的关键。我们要搞清楚它能执行什么形式的代码，支持64位长模式吗？</p><p>这个工作我们交给init_chkcpu()函数来干，由于我们要CPUID指令来检查CPU是否支持64位长模式，所以这个函数中需要找两个帮工：<strong>chk_cpuid、chk_cpu_longmode</strong>来干两件事，一个是检查CPU否支持CPUID指令，然后另一个用CPUID指令检查CPU支持64位长模式。</p><p>下面我们去写好它们，如下所示。</p><pre><code>//通过改写Eflags寄存器的第21位，观察其位的变化判断是否支持CPUID
int chk_cpuid()
{
    int rets = 0;
    __asm__ __volatile__(
        &quot;pushfl \n\t&quot;
        &quot;popl %%eax \n\t&quot;
        &quot;movl %%eax,%%ebx \n\t&quot;
        &quot;xorl $0x0200000,%%eax \n\t&quot;
        &quot;pushl %%eax \n\t&quot;
        &quot;popfl \n\t&quot;
        &quot;pushfl \n\t&quot;
        &quot;popl %%eax \n\t&quot;
        &quot;xorl %%ebx,%%eax \n\t&quot;
        &quot;jz 1f \n\t&quot;
        &quot;movl $1,%0 \n\t&quot;
        &quot;jmp 2f \n\t&quot;
        &quot;1: movl $0,%0 \n\t&quot;
        &quot;2: \n\t&quot;
        : &quot;=c&quot;(rets)
        :
        :);
    return rets;
}
//检查CPU是否支持长模式
int chk_cpu_longmode()
{
    int rets = 0;
    __asm__ __volatile__(
        &quot;movl $0x80000000,%%eax \n\t&quot;
        &quot;cpuid \n\t&quot; //把eax中放入0x80000000调用CPUID指令
        &quot;cmpl $0x80000001,%%eax \n\t&quot;//看eax中返回结果
        &quot;setnb %%al \n\t&quot; //不为0x80000001,则不支持0x80000001号功能
        &quot;jb 1f \n\t&quot;
        &quot;movl $0x80000001,%%eax \n\t&quot;
        &quot;cpuid \n\t&quot;//把eax中放入0x800000001调用CPUID指令，检查edx中的返回数据
        &quot;bt $29,%%edx  \n\t&quot; //长模式 支持位  是否为1
        &quot;setcb %%al \n\t&quot;
        &quot;1: \n\t&quot;
        &quot;movzx %%al,%%eax \n\t&quot;
        : &quot;=a&quot;(rets)
        :
        :);
    return rets;
}
//检查CPU主函数
void init_chkcpu(machbstart_t *mbsp)
{
    if (!chk_cpuid())
    {
        kerror(&quot;Your CPU is not support CPUID sys is die!&quot;);
        CLI_HALT();
    }
    if (!chk_cpu_longmode())
    {
        kerror(&quot;Your CPU is not support 64bits mode sys is die!&quot;);
        CLI_HALT();
    }
    mbsp-&gt;mb_cpumode = 0x40;//如果成功则设置机器信息结构的cpu模式为64位
    return;
}
</code></pre><p>上述代码中，检查CPU是否支持CPUID指令和检查CPU是否支持长模式，只要其中一步检查失败，我们就打印一条相应的提示信息，然后主动死机。<strong>这里需要你留意的是，最后设置机器信息结构中的mb_cpumode字段为64,mbsp正是传递进来的机器信息machbstart_t结构体的指针。</strong></p><h3>获取内存布局</h3><p>好了，CPU已经检查完成 ，合乎我们的要求。下面就要获取内存布局信息了，物理内存在物理地址空间中是一段一段的，描述一段内存有一个数据结构，如下所示。</p><pre><code>#define RAM_USABLE 1 //可用内存
#define RAM_RESERV 2 //保留内存不可使用
#define RAM_ACPIREC 3 //ACPI表相关的
#define RAM_ACPINVS 4 //ACPI NVS空间
#define RAM_AREACON 5 //包含坏内存
typedef struct s_e820{
    u64_t saddr;    /* 内存开始地址 */
    u64_t lsize;    /* 内存大小 */
    u32_t type;    /* 内存类型 */
}e820map_t;
</code></pre><p>获取内存布局信息就是获取这个结构体的数组，这个工作我们交给init_mem函数来干，这个函数需要完成两件事：一是获取上述这个结构体数组，二是检查内存大小，因为我们的内核对内存容量有要求，不能太小。</p><p>下面我们来动手实现这个init_mem函数。</p><pre><code>#define ETYBAK_ADR 0x2000
#define PM32_EIP_OFF (ETYBAK_ADR)
#define PM32_ESP_OFF (ETYBAK_ADR+4)
#define E80MAP_NR (ETYBAK_ADR+64)//保存e820map_t结构数组元素个数的地址
#define E80MAP_ADRADR (ETYBAK_ADR+68) //保存e820map_t结构数组的开始地址
void init_mem(machbstart_t *mbsp)
{
    e820map_t *retemp;
    u32_t retemnr = 0;
    mmap(&amp;retemp, &amp;retemnr);
    if (retemnr == 0)
    {
        kerror(&quot;no e820map\n&quot;);
    }
    //根据e820map_t结构数据检查内存大小
    if (chk_memsize(retemp, retemnr, 0x100000, 0x8000000) == NULL)
    {
        kerror(&quot;Your computer is low on memory, the memory cannot be less than 128MB!&quot;);
    }
    mbsp-&gt;mb_e820padr = (u64_t)((u32_t)(retemp));//把e820map_t结构数组的首地址传给mbsp-&gt;mb_e820padr 
    mbsp-&gt;mb_e820nr = (u64_t)retemnr;//把e820map_t结构数组元素个数传给mbsp-&gt;mb_e820nr 
    mbsp-&gt;mb_e820sz = retemnr * (sizeof(e820map_t));//把e820map_t结构数组大小传给mbsp-&gt;mb_e820sz 
    mbsp-&gt;mb_memsz = get_memsize(retemp, retemnr);//根据e820map_t结构数据计算内存大小。
    return;
}
</code></pre><p>上面最难写的是mmap函数。不过，我们还是有办法破解的。如果你理解了前面调用BIOS的机制，就会发现，<strong>只要调用了BIOS中断，就能获取e820map结构数组</strong>。</p><p>为了验证这个结论，我们来看一下mmap的函数调用关系：</p><pre><code>void mmap(e820map_t **retemp, u32_t *retemnr)
{
    realadr_call_entry(RLINTNR(0), 0, 0);
    *retemnr = *((u32_t *)(E80MAP_NR));
    *retemp = (e820map_t *)(*((u32_t *)(E80MAP_ADRADR)));
    return;
}
</code></pre><p>可以看到，mmap函数正是通过前面讲的<strong>realadr_call_entry函数</strong>，来调用实模式下的_getmmap函数的，并且在_getmmap函数中调用BIOS中断的。</p><pre><code>_getmmap:
	push ds
	push es
	push ss
	mov esi,0
	mov dword[E80MAP_NR],esi
	mov dword[E80MAP_ADRADR],E80MAP_ADR ;e820map结构体开始地址
	xor ebx,ebx
	mov edi,E80MAP_ADR
loop:
	mov eax,0e820h ;获取e820map结构参数
	mov ecx,20    ;e820map结构大小
	mov edx,0534d4150h ;获取e820map结构参数必须是这个数据
	int 15h  ;BIOS的15h中断
	jc .1
	add edi,20
	cmp edi,E80MAP_ADR+0x1000
	jg .1
	inc esi
	cmp ebx,0
	jne loop ;循环获取e820map结构
	jmp .2
.1:
	mov esi,0    ;出错处理，e820map结构数组元素个数为0
.2:
	mov dword[E80MAP_NR],esi ;e820map结构数组元素个数
	pop ss
	pop es
	pop ds
	ret
</code></pre><p>如果你不明白上面代码的原理，请回到“Cache与内存：程序放在哪儿”<a href="https://time.geekbang.org/column/article/376711">那节课</a>，看一下获取内存视图相关的知识点。</p><p>init_mem函数在调用mmap函数后，就会得到e820map结构数组，其首地址和数组元素个数由retemp，retemnr两个变量分别提供。</p><h3>初始化内核栈</h3><p>因为我们的操作系统是C语言写的，所以需要有栈，下面我们就来给即将运行的内核初始化一个栈。这个操作非常简单，就是在机器信息结构machbstart_t中，记录一下栈地址和栈大小，供内核在启动时使用。</p><p>不过，就算操作再简单，我们也要封装成函数来使用。让我们动手来写出这个函数吧，如下所示。</p><pre><code>#define IKSTACK_PHYADR (0x90000-0x10)
#define IKSTACK_SIZE 0x1000
//初始化内核栈
void init_krlinitstack(machbstart_t *mbsp)
{
    if (1 &gt; move_krlimg(mbsp, (u64_t)(0x8f000), 0x1001))
    {
        kerror(&quot;iks_moveimg err&quot;);
    }
    mbsp-&gt;mb_krlinitstack = IKSTACK_PHYADR;//栈顶地址
    mbsp-&gt;mb_krlitstacksz = IKSTACK_SIZE; //栈大小是4KB
    return;
}
</code></pre><p>init_krlinitstack函数非常简单，但是其中调用了一个move_krlimg函数你要注意，这个我已经帮你写好啦，它主要负责判断一个地址空间是否和内存中存放的内容有冲突。</p><p>因为我们的内存中已经放置了机器信息结构、内存视图结构数组、二级引导器、内核映像文件，所以在处理内存空间时不能和内存中已经存在的他们冲突，否则就要覆盖他们的数据。0x8f000～（0x8f000+0x1001），正是我们的内核栈空间，我们需要检测它是否和其它空间有冲突。</p><h3>放置内核文件与字库文件</h3><p>放置内核文件和字库文件这一步，也非常简单，甚至放置其它文件也一样。</p><p>因为我们的内核已经编译成了一个独立的二进制程序，和其它文件一起被打包到映像文件中了。所以我们必须要从映像中把它解包出来，将其放在特定的物理内存空间中才可以，放置字库文件和放置内核文件的原理一样，所以我们来一起实现。</p><pre><code>//放置内核文件
void init_krlfile(machbstart_t *mbsp)
{
//在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找kernel.bin文件
    u64_t sz = r_file_to_padr(mbsp, IMGKRNL_PHYADR, &quot;kernel.bin&quot;);
    if (0 == sz)
    {
        kerror(&quot;r_file_to_padr err&quot;);
    }
    //放置完成后更新机器信息结构中的数据
    mbsp-&gt;mb_krlimgpadr = IMGKRNL_PHYADR;
    mbsp-&gt;mb_krlsz = sz;
    //mbsp-&gt;mb_nextwtpadr始终要保持指向下一段空闲内存的首地址 
    mbsp-&gt;mb_nextwtpadr = P4K_ALIGN(mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz);
    mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz;
    return;
}
//放置字库文件
void init_defutfont(machbstart_t *mbsp)
{
    u64_t sz = 0;
    //获取下一段空闲内存空间的首地址 
    u32_t dfadr = (u32_t)mbsp-&gt;mb_nextwtpadr;
//在映像中查找相应的文件，并复制到对应的地址，并返回文件的大小，这里是查找font.fnt文件
    sz = r_file_to_padr(mbsp, dfadr, &quot;font.fnt&quot;);
    if (0 == sz)
    {
        kerror(&quot;r_file_to_padr err&quot;);
    }
    //放置完成后更新机器信息结构中的数据
    mbsp-&gt;mb_bfontpadr = (u64_t)(dfadr);
    mbsp-&gt;mb_bfontsz = sz;
    //更新机器信息结构中下一段空闲内存的首地址  
    mbsp-&gt;mb_nextwtpadr = P4K_ALIGN((u32_t)(dfadr) + sz);
    mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_bfontpadr + mbsp-&gt;mb_bfontsz;
    return;
}
</code></pre><p>以上代码的注释已经很清楚了，都是调用r_file_to_padr函数在映像中查找kernel.bin和font.fnt文件，并复制到对应的空闲内存空间中。</p><p>请注意，由于内核是代码数据，所以必须要复制到指定的内存空间中。r_file_to_padr函数我已经帮你写好了，其中的原理在前面的内容里已经做了说明，这里不再展开。</p><h3>建立MMU页表数据</h3><p>前面解决了文件放置问题，我们还要解决另一个问题——建立MMU页表。</p><p>我们在二级引导器中建立MMU页表数据，目的就是要在内核加载运行之初开启长模式时，MMU需要的页表数据已经准备好了。</p><p>由于我们的内核虚拟地址空间从0xffff800000000000开始，所以我们这个虚拟地址映射到从物理地址0开始，大小都是0x400000000即16GB，也就是说我们要虚拟地址空间：0xffff800000000000～0xffff800400000000 映射到物理地址空间0～0x400000000。</p><p>我们为了简化编程，使用<strong>长模式下的2MB分页方式</strong>，下面我们用代码实现它，如下所示。</p><pre><code>#define KINITPAGE_PHYADR 0x1000000
void init_bstartpages(machbstart_t *mbsp)
{
    //顶级页目录
    u64_t *p = (u64_t *)(KINITPAGE_PHYADR);//16MB地址处
    //页目录指针
    u64_t *pdpte = (u64_t *)(KINITPAGE_PHYADR + 0x1000);
    //页目录
    u64_t *pde = (u64_t *)(KINITPAGE_PHYADR + 0x2000);
    //物理地址从0开始
    u64_t adr = 0;
    if (1 &gt; move_krlimg(mbsp, (u64_t)(KINITPAGE_PHYADR), (0x1000 * 16 + 0x2000)))
    {
        kerror(&quot;move_krlimg err&quot;);
    }
    //将顶级页目录、页目录指针的空间清0
    for (uint_t mi = 0; mi &lt; PGENTY_SIZE; mi++)
    {
        p[mi] = 0;
        pdpte[mi] = 0;
    }
    //映射
    for (uint_t pdei = 0; pdei &lt; 16; pdei++)
    {
        pdpte[pdei] = (u64_t)((u32_t)pde | KPDPTE_RW | KPDPTE_P);
        for (uint_t pdeii = 0; pdeii &lt; PGENTY_SIZE; pdeii++)
        {//大页KPDE_PS 2MB，可读写KPDE_RW，存在KPDE_P
            pde[pdeii] = 0 | adr | KPDE_PS | KPDE_RW | KPDE_P;
            adr += 0x200000;
        }
        pde = (u64_t *)((u32_t)pde + 0x1000);
    }
    //让顶级页目录中第0项和第((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff项，指向同一个页目录指针页  
    p[((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff] = (u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P);
    p[0] = (u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P);
    //把页表首地址保存在机器信息结构中
    mbsp-&gt;mb_pml4padr = (u64_t)(KINITPAGE_PHYADR);
    mbsp-&gt;mb_subpageslen = (u64_t)(0x1000 * 16 + 0x2000);
    mbsp-&gt;mb_kpmapphymemsz = (u64_t)(0x400000000);
    return;
}
</code></pre><p>这个函数的代码写得非常简单，<strong>映射的核心逻辑由两重循环控制</strong>，外层循环控制页目录指针顶，只有16项，其中每一项都指向一个页目录，每个页目录中有512个物理页地址。</p><p>物理地址每次增加2MB，这是由26～30行的内层循环控制，每执行一次外层循环就要执行512次内层循环。</p><p>最后，顶级页目录中第0项和第((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff项，指向同一个页目录指针页，这样的话就能让虚拟地址：0xffff800000000000～0xffff800400000000和虚拟地址：0～0x400000000，访问到同一个物理地址空间0～0x400000000，这样做是有目的，<strong>内核在启动初期，虚拟地址和物理地址要保持相同。</strong></p><h3>设置图形模式</h3><p>在计算机加电启动时，计算机上显卡会自动进入文本模式，文本模式只能显示ASCII字符，不能显示汉字和图形，所以我们要让显卡切换到图形模式。</p><p>切换显卡模式依然要用BIOS中断，这个调用原理我们前面已经了如指掌。在实模式切换显卡模式的汇编代码，我已经帮你写好了，下面我们只要写个C函数调用它们就好了，代码如下所示。</p><pre><code>void init_graph(machbstart_t* mbsp)
{
    //初始化图形数据结构
    graph_t_init(&amp;mbsp-&gt;mb_ghparm);
    //获取VBE模式，通过BIOS中断
    get_vbemode(mbsp);
    //获取一个具体VBE模式的信息，通过BIOS中断
    get_vbemodeinfo(mbsp);
    //设置VBE模式，通过BIOS中断
    set_vbemodeinfo();
    return;
}
</code></pre><p>上面init_graph函数中的这些处理VBE模式的代码，我已经帮你写好，你可以自己在graph.c文件查看。</p><p>什么？你不懂VBE，其实我开始也不懂，后来通过搜寻资料才知道。</p><p>其实VBE是显卡的一个图形规范标准，它定义了显卡的几种图形模式，每个模式包括屏幕分辨率，像素格式与大小，显存大小。调用BIOS 10h中断可以返回这些数据结构。<a href="https://vesa.org/">如果你实在对VBE感兴趣，可以自行阅读其规范</a> 。</p><p>这里我们选择使用了VBE的118h模式，该模式下屏幕分辨率为1024x768，显存大小是16.8MB。显存开始地址一般为0xe0000000。</p><p>屏幕分辨率为1024x768，即把屏幕分成768行，每行1024个像素点，但每个像素点占用显存的32位数据（4字节，红、绿、蓝、透明各占8位）。我们只要往对应的显存地址写入相应的像素数据，屏幕对应的位置就能显示了。</p><p>每个像素点，我们可以用如下数据结构表示：</p><pre><code>typedef struct s_PIXCL
{
    u8_t cl_b; //蓝
    u8_t cl_g; //绿
    u8_t cl_r; //红
    u8_t cl_a; //透明
}__attribute__((packed)) pixcl_t;

#define BGRA(r,g,b) ((0|(r&lt;&lt;16)|(g&lt;&lt;8)|b))
//通常情况下用pixl_t 和 BGRA宏
typedef u32_t pixl_t;
</code></pre><p>我们再来看看屏幕像素点和显存位置对应的计算方式：</p><pre><code>u32_t* dispmem = (u32_t*)mbsp-&gt;mb_ghparm.gh_framphyadr;
dispmem[x + (y * 1024)] = pix;
//x，y是像素的位置
</code></pre><h3>串联</h3><p>好了，所有的实施工作的函数已经完成了，现在我们需要在init_bstartparm()函数中把它们串联起来，即按照事情的先后顺序，依次调用它们完成相应的工作，实现检查、收集机器信息，设置工作环境。</p><pre><code>void init_bstartparm()
{
    machbstart_t *mbsp = MBSPADR;
    machbstart_t_init(mbsp);
    //检查CPU
    init_chkcpu(mbsp);
    //获取内存布局
    init_mem(mbsp);
    //初始化内核栈
    init_krlinitstack(mbsp);
    //放置内核文件
    init_krlfile(mbsp);
    //放置字库文件
    init_defutfont(mbsp);
    init_meme820(mbsp);
    //建立MMU页表
    init_bstartpages(mbsp);
    //设置图形模式
    init_graph(mbsp);
    return;
}
</code></pre><p>到这里，init_bstartparm()函数就成功完成了它的使命。</p><h2>显示Logo</h2><p>前面我们已经设置了图形模式，也应该要展示一下了，检查一下工作成果。</p><p>我们来显示一下我们内核的logo。其实在二级引导器中，我已经帮你写好了显示logo函数，而logo文件是个<strong>24位的位图文件</strong>，目前为了简单起见，我们<strong>只支持这种格式的图片文件</strong>。下面我们去调用这个函数。</p><pre><code>void logo(machbstart_t* mbsp)
{
    u32_t retadr=0,sz=0;
    //在映像文件中获取logo.bmp文件
    get_file_rpadrandsz(&quot;logo.bmp&quot;,mbsp,&amp;retadr,&amp;sz);
    if(0==retadr)
    {
        kerror(&quot;logo getfilerpadrsz err&quot;);
    }
    //显示logp文件中的图像数据
    bmp_print((void*)retadr,mbsp);
    return;
}
void init_graph(machbstart_t* mbsp)
{    
    //……前面代码省略
    //显示
    logo(mbsp);
    return;
}
</code></pre><p>在图格式的文件中，除了文件头的数据就是图形像素点的数据，只不过24位的位图每个像素占用3字节，并且位置是倒排的，即第一个像素的数据是在文件的最后，依次类推。我们只要依次将位图文件的数据，按照倒排次序写入显存中，这样就可以显示了。</p><p>我们需要把二级引导器的文件和logo文件打包成映像文件，然后放在虚拟硬盘中。</p><p>复制文件到虚拟硬盘中得先mount，然后复制，最后转换成VDI格式的虚拟硬盘，再挂载到虚拟机上启动就行了。这也是为什么要手动建立硬盘的原因，打包命令如下。</p><pre><code>lmoskrlimg -m k -lhf initldrimh.bin -o Cosmos.eki -f initldrsve.bin initldrkrl.bin font.fnt logo.bmp
</code></pre><p>如果手动打命令对你来说还是比较难，也别担心，我已经帮你写好了make脚本，你只需要进入代码目录中make vboxtest 就行了，运行结果如下 。</p><p><img src="https://static001.geekbang.org/resource/image/c3/y0/c3d4f0b072b837f208fbd52749913yy0.jpg" alt="" title="代码运行结果示意图"></p><p>啊哈！终于显示了logo。是不是挺有成就感的？这至少证明我们辛苦写的代码是正确的。</p><p>但是目前我们的代码执行流还在二级引导器中，我们的目的是开发自己的操作系统，不，我们是要开发Cosmos。</p><p><strong>后面，我们正式用Cosmos命名我们的操作系统。</strong>Cosmos可以翻译成宇宙，尽管它刚刚诞生，但我对它充满期待，所以用了这样一个能够“包括万物，包罗万象”的名字。</p><h2>进入Cosmos</h2><p>我们在调用Cosmos第一个C函数之前，我们依然要写一小段汇编代码，切换CPU到长模式，初始化CPU寄存器和C语言要用的栈。因为目前代码执行流在二级引导器中，进入到Cosmos中这样在二级引导器中初始过的东西都不能用了。</p><p>因为CPU进入了长模式，寄存器的位宽都变了，所以需要重新初始化。让我们一起来写这段汇编代码吧，我们先在Cosmos/hal/x86/下建立一个init_entry.asm文件，写上后面这段代码。</p><pre><code>[section .start.text]
[BITS 32]
_start:
    cli
    mov ax,0x10
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov gs,ax
    lgdt [eGdtPtr]        
    ;开启 PAE
    mov eax, cr4
    bts eax, 5                      ; CR4.PAE = 1
    mov cr4, eax
    mov eax, PML4T_BADR             ;加载MMU顶级页目录
    mov cr3, eax	
    ;开启 64bits long-mode
    mov ecx, IA32_EFER
    rdmsr
    bts eax, 8                      ; IA32_EFER.LME =1
    wrmsr
    ;开启 PE 和 paging
    mov eax, cr0
    bts eax, 0                      ; CR0.PE =1
    bts eax, 31
    ;开启 CACHE       
    btr eax,29		                ; CR0.NW=0
    btr eax,30		                ; CR0.CD=0  CACHE
    mov cr0, eax                    ; IA32_EFER.LMA = 1
    jmp 08:entry64
[BITS 64]
entry64:
    mov ax,0x10
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov gs,ax
    xor rax,rax
    xor rbx,rbx
    xor rbp,rbp
    xor rcx,rcx
    xor rdx,rdx
    xor rdi,rdi
    xor rsi,rsi
    xor r8,r8
    xor r9,r9
    xor r10,r10
    xor r11,r11
    xor r12,r12
    xor r13,r13
    xor r14,r14
    xor r15,r15
    mov rbx,MBSP_ADR
    mov rax,KRLVIRADR
    mov rcx,[rbx+KINITSTACK_OFF]
    add rax,rcx
    xor rcx,rcx
    xor rbx,rbx
    mov rsp,rax
    push 0
    push 0x8
    mov rax,hal_start                 ;调用内核主函数
    push rax
    dw 0xcb48
    jmp $
[section .start.data]
[BITS 32]
x64_GDT:
enull_x64_dsc:	dq 0	
ekrnl_c64_dsc:  dq 0x0020980000000000   ; 64-bit 内核代码段
ekrnl_d64_dsc:  dq 0x0000920000000000   ; 64-bit 内核数据段
euser_c64_dsc:  dq 0x0020f80000000000   ; 64-bit 用户代码段
euser_d64_dsc:  dq 0x0000f20000000000   ; 64-bit 用户数据段
eGdtLen			equ	$ - enull_x64_dsc   ; GDT长度
eGdtPtr:		dw eGdtLen - 1			; GDT界限
				dq ex64_GDT
</code></pre><p>上述代码中，1～11行表示加载70～75行的GDT，13～17行是设置MMU并加载在二级引导器中准备好的MMU页表，19～30行是开启长模式并打开Cache，34～54行则是初始化长模式下的寄存器，55～61行是读取二级引导器准备的机器信息结构中的栈地址，并用这个数据设置RSP寄存器。</p><p>最关键的是63～66行，它开始把8和hal_start函数的地址压入栈中。dw 0xcb48是直接写一条指令的机器码——0xcb48，这是一条返回指令。这个返回指令有点特殊，它会把栈中的数据分别弹出到RIP，CS寄存器，这正是为了调用我们Cosmos的<strong>第一个C函数hal_start</strong>。</p><h2>重点回顾</h2><p>这是我们设置工作模式与环境的最后一课，到此为止我们的二级引导器已经建立起来了，成功从 GRUB手中接过了权柄，开始了它自己的一系列工作，二级引导器完成的工作不算少，我来帮你梳理一下，重点如下。</p><p>1.二级引导器彻底摆脱了GRUB的控制之后，就开始检查CPU，获取内存布局信息，确认是不是我们要求的CPU和内存大小，接着初始化内核栈、放置好内核文件和字库文件，建立MMU页表数据和设置好图形模式，为后面运行内核做好准备。</p><p>2.当二级引导器完成了上述功能后，就会显示我们操作系统的logo，这标志着二级引导器所有的工作一切正常。</p><p>3.进入Cosmos，我们的二级引导器通过跳转到Cosmos的入口，结束了自己光荣使命，Cosmos的入口是一小段汇编代码，主要是开启CPU的长模式，最后调用了Cosmos的第一个C函数hal_start。</p><p>你想过吗？我们的二级引导器还可以做更多的事情，其实还可以在二级引导器中获取ACPI表，进而获取CPU数量和其它设备信息，期待你的实现。</p><h2>思考题</h2><p>请你想一下，init_bstartparm()函数中的init_mem820()函数，这个函数到底干了什么？</p><p>欢迎你在留言区跟我互动。如果你身边有朋友对手写操作系统有热情，也欢迎你把这节课转发给他。</p><h2>精选留言：</h2>
        <ul>
        
<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            neohope  2021-06-05 02:36:57
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            大体上整理了一下，有几处没弄清楚【下半部分】：<br>11、返回到bstartparm.c<br>调用了chkcpmm.c的init_bstartpages<br><br>12、然后调用到了fs.c的move_krlimg函数申请了内存，建立了MMU页表：<br>顶级页目录，开始于0x1000000<br>页目录指针目录，开始于0x1001000，，共16项 ，其中每一项都指向一个页目录<br>页目录，开始于0x1002000， 每页指向512 个物理页，每页2MB【 0x200000】<br><br>让物理地址p[0]和虚拟地址p[((KRNL_VIRTUAL_ADDRESS_START) &gt;&gt; KPML4_SHIFT) &amp; 0x1ff]，指向同一个页目录指针页，确保内核在启动初期，虚拟地址和物理地址要保持相同<br>没搞清楚为什么虚拟地址是这个，也暂时没搞清楚为何要指向(u64_t)((u32_t)pdpte | KPML4_RW | KPML4_P)<br><br>最后，把页表首地址保存在机器信息结构中<br><br>13、返回到bstartparm.c<br>调用了graph.c的init_graph<br>A、初始化了数据结构<br><br>B、调用init_bgadevice<br>首先获取GBA设备ID<br>检查设备最大分辨率<br>设置显示参数，并将参数保存到mbsp结构中<br><br>C、如果不是图形模式，要通过BIOS中断进行切换，设置显示参数，并将参数保存到mbsp结构中：<br>获取VBE模式，通过BIOS中断<br>获取一个具体VBE模式的信息，通过BIOS中断<br>设置VBE模式，通过BIOS中断<br>这三个方法同样用到了realadr_call_entry，调用路径与上面_getmmap类似，不再展开<br><br>D、初始化了一块儿内存<br>感觉会与物理地址与虚拟地址之间转换由一定关系<br><br>E、进行logo显示<br>调用get_file_rpadrandsz定位到位图文件<br>调用bmp_print，读入像素点，BGRA转换<br>最后调用write_pixcolor，写入到mbsp-&gt;mb_ghparm正确的位置，图像就显示出来了<br><br>14、然后一路返回<br>到bstartparm.c的init_bstartparm<br>到ldrkrlentry.c的ldrkrl_entry<br>到ldrkrl32.asm的call ldrkrl_entry<br>再往下是jmp 0x2000000<br>这个地址就是IMGKRNL_PHYADR，就是刚才放Cosmos.eki的位置<br><br>15、然后就接上了本节最后一部分内容了，不容易啊！哈哈哈！ [2赞]
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            neohope  2021-06-05 02:34:38
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            大体上整理了一下，有几处没弄清楚【上半部分】：<br><br>1、bstartparm.c从init_bstartparm函数开始<br>A、初始化machbstart_t<br><br>2、跳转到chkcpmm.c的init_chkcpu函数，检查是否支持CPUID功能<br>A、init_chkcpu函数<br>CPU自带检查方式：无法反转 Eflags第21位，表示CPU支持CPUID功能<br>如果反转成功，说明不支持CPUID，打印内核错误并退出<br>B、然后调用CPUID功能，判断是否支持长模式<br>先通过通过0x80000000参数，调用cpuid命令，判断CPU是否支持扩展处理器信息【返回值比0x80000000大】<br>如果支持，通过0x80000001参数，调用cpuid命令，获取扩展处理器信息，然后检测第29位，判断是否支持长模式<br>如果不支持，打印内核错误并退出<br>C、设置mbsp中cpumode为64位<br><br>3、返回chkcpmm.c，继续检测内存信息<br>A、跳转到chkcpmm.c的init_mem函数<br>B、通过mmap调用realadr_call_entry(RLINTNR(0),0,0)<br>C、实际会执行ldrkrl32.asm的realadr_call_entry<br>D、跳转到save_eip_jmp<br>E、最后在cpmty_mode处，把 0x18：0x1000 [段描述索引：段内的偏移]，装入到 CS：EIP 寄存器中<br>F、而EIP这个地址恰恰是内存中initldrsve.bin的位置，因为之前write_realintsvefile把数据加载到了REALDRV_PHYADR  0x1000【而且在initldrsve.lds好像也指定了段内偏移0x1000】<br>同时CS中段描述符为k16cd_dsc，说明是16位代码段，可以执行，CPU继续从EIP地址执行<br>G、而initldrsve.bin是由realintsve.asm编译得到的，所以实际会继续执行realintsve.asm中代码<br>H、然后到real_entry这里，通过传入的参数ax，判断调用func_table哪个方法<br>当前参数位0，ax就是0，也就是调用了func_table的第一个函数_getmmap<br>I、_getmmap中，通过BIOS的15h中断，获取内存信息<br>J、检查内存信息，如果小于128M，打印内核错误并退出<br>K、设置machbstart_t内存相关参数<br>L、然后调用了init_acpi<br><br>4、在init_acpi中<br>通过“RSD PTR ”及校验，判断是否支持ACPI功能<br>不支持则 打印内核错误并退出<br><br>5、返回到bstartparm.c<br>好像是确认了一下initldrsve.bin的状态，获取了一下文件内存地址及大小<br><br>6、返回到bstartparm.c，继续调用到chkcpmm.c的init_krlinitstack函数<br><br>7、然后调用到了fs.c的move_krlimg函数<br>首先判断新申请的地址，是否可用<br>-》如果可用直接使用<br>-》如果不可用，则判断申请的内存大小是否超出设备物理大小<br>-》-》如果超出大小，系统打印内核错误并退出<br>-》-》如果不超出大小，系统会将内存对齐到0x1000后，将initldrsve.bin移动到新位置，并修正地址<br>整体来说move_krlimg更像是申请内存，但不知道为何要不断驱赶initldrsve.bin文件<br><br>8、返回到chkcpmm.c<br>初始化栈顶和栈大小<br><br>9、返回到bstartparm.c<br>调用fs.c的init_krlfile函数，将Cosmos.eki加载到了IMGKRNL_PHYADR<br>并填写了mbsp相关内容<br><br>10、返回到bstartparm.c<br>调用了chkcpmm.c的init_meme820函数<br>然后调用到了fs.c的move_krlimg函数申请了内存，拷贝了一份e820map_t到Cosmos.eki之后的地址，并修正mbsp指向新地址<br>感觉和内存保护 或 物理地址与虚拟地址之间转换有一定关系 [1赞]
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            pedro  2021-06-04 07:30:19
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            思考题还是挺麻烦的，主要是没有注释啊，很多字段的含义都是靠猜，文章也没有介绍到这些。<br>首先是 init_mem820 这个函数本身：<br>```c<br>void init_meme820(machbstart_t *mbsp)<br>{<br>    e820map_t *semp = (e820map_t *)((u32_t)(mbsp-&gt;mb_e820padr)); &#47;&#47;  e820数组地址<br>    u64_t senr = mbsp-&gt;mb_e820nr; &#47;&#47; 个数<br>    e820map_t *demp = (e820map_t *)((u32_t)(mbsp-&gt;mb_nextwtpadr));<br>    if (1 &gt; move_krlimg(mbsp, (u64_t)((u32_t)demp), (senr * (sizeof(e820map_t)))))<br>    {<br>        kerror(&quot;move_krlimg err&quot;);<br>    }<br><br>    m2mcopy(semp, demp, (sint_t)(senr * (sizeof(e820map_t))));<br>    mbsp-&gt;mb_e820padr = (u64_t)((u32_t)(demp));<br>    mbsp-&gt;mb_e820sz = senr * (sizeof(e820map_t));<br>    mbsp-&gt;mb_nextwtpadr = P4K_ALIGN((u32_t)(demp) + (u32_t)(senr * (sizeof(e820map_t))));<br>    mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_e820padr + mbsp-&gt;mb_e820sz;<br>    return;<br>}<br>```<br>我们发现这个函数实际上在拷贝内存，即将 semp 指针处的 senr * (sizeof(e820map_t) 内存大小拷贝到<br>demp 处，而 demp 的地址正是 mb_nextwtpadr，那么这个 mb_nextwtpadr 是怎么来的呢？在init_krlfile函数中可以大致猜测：<br><br>```c<br>void init_krlfile(machbstart_t *mbsp)<br>{<br>    u64_t sz = r_file_to_padr(mbsp, IMGKRNL_PHYADR, &quot;kernel.bin&quot;);<br>    if (0 == sz)<br>    {<br>        kerror(&quot;r_file_to_padr err&quot;);<br>    }<br>    mbsp-&gt;mb_krlimgpadr = IMGKRNL_PHYADR;<br>    mbsp-&gt;mb_krlsz = sz;<br>    &#47;&#47; 页对齐<br>    mbsp-&gt;mb_nextwtpadr = P4K_ALIGN(mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz);<br>    mbsp-&gt;mb_kalldendpadr = mbsp-&gt;mb_krlimgpadr + mbsp-&gt;mb_krlsz;<br>    return;<br>}<br>```<br>没错，mb_nextwtpadr 正是跳过内核起始地址+内核大小后的第一个页地址，注意需要4k对齐。<br>那么刚才内存拷贝的意图也很明显，对于初始化后的内存，内核本身的内存映射是不可访问的，必须保护充分内核，所以 init_mem820 函数的作用是跳过内核初始化内存。<br>由于代码无注释，文中篇幅有限，如有错误，多多指正，望海涵~ [2赞]
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            blentle  2021-06-04 10:16:21
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            首先，这个函数为啥这么命名，没整明白 [2赞]
        </div>
        
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            springXu  2021-06-04 00:58:05
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            还很奇怪mem820这个函数怎么没有细讲。原来是思考题。 [1赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">编辑回复2021-06-05 00:21:02</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">哈哈 是滴。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            嗣树  2021-06-04 11:56:54
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            回答下思考题，init_mem820() 的作用？<br><br>先说结论，init_mem820 函数的作用是将 init_mem() 中获取到的内存信息转存到字体文件之后，其实就是为它找一个安稳的地方存放。<br><br>简单分析一下：<br>init_mem() -&gt; mmap() -&gt; realadr_call_entry()<br>然后进入实模式调用中断，实模式的访址能力是有限，我们为中断处理指定临时的地址(E80MAP_ADRADR) 存放内存信息数组<br>#define ETYBAK_ADR 0x2000<br>#define E80MAP_ADRADR (ETYBAK_ADR+68)<br><br>接下来在把内核文件加载到指定内存地址，字体文件紧随其后，然后就是我们收集到的信息，我们还要把放在临时位置的信息复制出来。<br> 
        </div>
        
    </div>
</li>
            </ul>
</div>
</body>
</html>