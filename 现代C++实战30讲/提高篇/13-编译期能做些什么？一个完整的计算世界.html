<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>13-编译期能做些什么？一个完整的计算世界</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <style>
        html {
            color: #333;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-rendering: optimizelegibility;
            font-family: Helvetica Neue, PingFang SC, Verdana, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, sans-serif
        }

        html.borderbox *,
        html.borderbox :after,
        html.borderbox :before {
            box-sizing: border-box
        }

        article,
        aside,
        blockquote,
        body,
        button,
        code,
        dd,
        details,
        dl,
        dt,
        fieldset,
        figcaption,
        figure,
        footer,
        form,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        header,
        hr,
        input,
        legend,
        li,
        menu,
        nav,
        ol,
        p,
        pre,
        section,
        td,
        textarea,
        th,
        ul {
            margin: 0;
            padding: 0
        }

        article,
        aside,
        details,
        figcaption,
        figure,
        footer,
        header,
        menu,
        nav,
        section {
            display: block
        }

        audio,
        canvas,
        video {
            display: inline-block
        }

        body,
        button,
        input,
        select,
        textarea {
            font: 300 1em/1.8 PingFang SC, Lantinghei SC, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, Helvetica, sans-serif
        }

        button::-moz-focus-inner,
        input::-moz-focus-inner {
            padding: 0;
            border: 0
        }

        table {
            border-collapse: collapse;
            border-spacing: 0
        }

        fieldset,
        img {
            border: 0
        }

        blockquote {
            position: relative;
            color: #999;
            font-weight: 400;
            border-left: 1px solid #1abc9c;
            padding-left: 1em;
            margin: 1em 3em 1em 2em
        }

        @media only screen and (max-width: 640px) {
            blockquote {
                margin: 1em 0
            }
        }

        abbr,
        acronym {
            border-bottom: 1px dotted;
            font-variant: normal
        }

        abbr {
            cursor: help
        }

        del {
            text-decoration: line-through
        }

        address,
        caption,
        cite,
        code,
        dfn,
        em,
        th,
        var {
            font-style: normal;
            font-weight: 400
        }

        ol,
        ul {
            list-style: none
        }

        caption,
        th {
            text-align: left
        }

        q:after,
        q:before {
            content: ""
        }

        sub,
        sup {
            font-size: 75%;
            line-height: 0;
            position: relative
        }

        :root sub,
        :root sup {
            vertical-align: baseline
        }

        sup {
            top: -.5em
        }

        sub {
            bottom: -.25em
        }

        a {
            color: #1abc9c
        }

        a:hover {
            text-decoration: underline
        }

        .typo a {
            border-bottom: 1px solid #1abc9c
        }

        .typo a:hover {
            border-bottom-color: #555;
            color: #555
        }

        .typo a:hover,
        a,
        ins {
            text-decoration: none
        }

        .typo-u,
        u {
            text-decoration: underline
        }

        mark {
            background: #fffdd1;
            border-bottom: 1px solid #ffedce;
            padding: 2px;
            margin: 0 5px
        }

        code,
        pre,
        pre tt {
            font-family: Courier, Courier New, monospace
        }

        pre {
            background: hsla(0, 0%, 97%, .7);
            border: 1px solid #ddd;
            padding: 1em 1.5em;
            display: block;
            -webkit-overflow-scrolling: touch
        }

        hr {
            border: none;
            border-bottom: 1px solid #cfcfcf;
            margin-bottom: .8em;
            height: 10px
        }

        .typo-small,
        figcaption,
        small {
            font-size: .9em;
            color: #888
        }

        b,
        strong {
            font-weight: 700;
            color: #000
        }

        [draggable] {
            cursor: move
        }

        .clearfix:after,
        .clearfix:before {
            content: "";
            display: table
        }

        .clearfix:after {
            clear: both
        }

        .clearfix {
            zoom: 1
        }

        .textwrap,
        .textwrap td,
        .textwrap th {
            word-wrap: break-word;
            word-break: break-all
        }

        .textwrap-table {
            table-layout: fixed
        }

        .serif {
            font-family: Palatino, Optima, Georgia, serif
        }

        .typo-dl,
        .typo-form,
        .typo-hr,
        .typo-ol,
        .typo-p,
        .typo-pre,
        .typo-table,
        .typo-ul,
        .typo dl,
        .typo form,
        .typo hr,
        .typo ol,
        .typo p,
        .typo pre,
        .typo table,
        .typo ul,
        blockquote {
            margin-bottom: 1rem
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-family: PingFang SC, Helvetica Neue, Verdana, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, sans-serif;
            color: #000;
            line-height: 1.35
        }

        .typo-h1,
        .typo-h2,
        .typo-h3,
        .typo-h4,
        .typo-h5,
        .typo-h6,
        .typo h1,
        .typo h2,
        .typo h3,
        .typo h4,
        .typo h5,
        .typo h6 {
            margin-top: 1.2em;
            margin-bottom: .6em;
            line-height: 1.35
        }

        .typo-h1,
        .typo h1 {
            font-size: 2em
        }

        .typo-h2,
        .typo h2 {
            font-size: 1.8em
        }

        .typo-h3,
        .typo h3 {
            font-size: 1.6em
        }

        .typo-h4,
        .typo h4 {
            font-size: 1.4em
        }

        .typo-h5,
        .typo-h6,
        .typo h5,
        .typo h6 {
            font-size: 1.2em
        }

        .typo-ul,
        .typo ul {
            margin-left: 1.3em;
            list-style: disc
        }

        .typo-ol,
        .typo ol {
            list-style: decimal;
            margin-left: 1.9em
        }

        .typo-ol ol,
        .typo-ol ul,
        .typo-ul ol,
        .typo-ul ul,
        .typo li ol,
        .typo li ul {
            margin-bottom: .8em;
            margin-left: 2em
        }

        .typo-ol ul,
        .typo-ul ul,
        .typo li ul {
            list-style: circle
        }

        .typo-table td,
        .typo-table th,
        .typo table caption,
        .typo table td,
        .typo table th {
            border: 1px solid #ddd;
            padding: .5em 1em;
            color: #666
        }

        .typo-table th,
        .typo table th {
            background: #fbfbfb
        }

        .typo-table thead th,
        .typo table thead th {
            background: hsla(0, 0%, 95%, .7)
        }

        .typo table caption {
            border-bottom: none
        }

        .typo-input,
        .typo-textarea {
            -webkit-appearance: none;
            border-radius: 0
        }

        .typo-em,
        .typo em,
        caption,
        legend {
            color: #000;
            font-weight: inherit
        }

        .typo-em {
            position: relative
        }

        .typo-em:after {
            position: absolute;
            top: .65em;
            left: 0;
            width: 100%;
            overflow: hidden;
            white-space: nowrap;
            content: "\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB"
        }

        .typo img {
            max-width: 100%
        }

        .common-content {
            font-weight: 400;
            color: #353535;
            line-height: 1.75rem;
            white-space: normal;
            word-break: normal;
            font-size: 1rem
        }

        .common-content img {
            display: block;
            max-width: 100%;
            background-color: #eee
        }

        .common-content audio,
        .common-content video {
            width: 100%;
            background-color: #eee
        }

        .common-content center,
        .common-content font {
            margin-top: 1rem;
            display: inline-block
        }

        .common-content center {
            width: 100%
        }

        .common-content pre {
            margin-top: 1rem;
            padding-left: 0;
            padding-right: 0;
            position: relative;
            overflow: hidden
        }

        .common-content pre code {
            font-size: .8rem;
            font-family: Consolas, Liberation Mono, Menlo, monospace, Courier;
            display: block;
            width: 100%;
            box-sizing: border-box;
            padding-left: 1rem;
            padding-right: 1rem;
            overflow-x: auto
        }

        .common-content hr {
            border: none;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            border-top: 1px solid #f5f5f5;
            height: 1px;
            background: none
        }

        .common-content b,
        .common-content h1,
        .common-content h2,
        .common-content h3,
        .common-content h4,
        .common-content h5,
        .common-content strong {
            font-weight: 700
        }

        .common-content h1,
        .common-content h2 {
            font-size: 1.125rem;
            margin-bottom: .45rem
        }

        .common-content h3,
        .common-content h4,
        .common-content h5 {
            font-size: 1rem;
            margin-bottom: .45rem
        }

        .common-content p {
            font-weight: 400;
            color: #353535;
            margin-top: .15rem
        }

        .common-content .orange {
            color: #ff5a05
        }

        .common-content .reference {
            font-size: 1rem;
            color: #888
        }

        .custom-rich-content h1 {
            margin-top: 0;
            font-weight: 400;
            font-size: 15.25px;
            border-bottom: 1px solid #eee;
            line-height: 2.8
        }

        .custom-rich-content li,
        .custom-rich-content p {
            font-size: 14px;
            color: #888;
            line-height: 1.6
        }

        table.hljs-ln {
            margin-bottom: 0;
            border-spacing: 0;
            border-collapse: collapse
        }

        table.hljs-ln,
        table.hljs-ln tbody,
        table.hljs-ln td,
        table.hljs-ln tr {
            box-sizing: border-box
        }

        table.hljs-ln td {
            padding: 0;
            border: 0
        }

        table.hljs-ln td.hljs-ln-numbers {
            min-width: 15px;
            color: rgba(27, 31, 35, .3);
            text-align: right;
            white-space: nowrap;
            cursor: pointer;
            user-select: none
        }

        table.hljs-ln td.hljs-ln-code,
        table.hljs-ln td.hljs-ln-numbers {
            font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;
            font-size: 12px;
            line-height: 20px;
            vertical-align: top
        }

        table.hljs-ln td.hljs-ln-code {
            position: relative;
            padding-right: 10px;
            padding-left: 10px;
            overflow: visible;
            color: #24292e;
            word-wrap: normal;
            white-space: pre
        }

        video::-webkit-media-controls {
            overflow: hidden !important
        }

        video::-webkit-media-controls-enclosure {
            width: calc(100% + 32px);
            margin-left: auto
        }

        ._29HP61GA_0 {
            max-width:800px;
            margin:0 auto;
            margin-bottom: 20px;
            font-weight: 400;
            color: #353535;
            line-height: 1.76;
            white-space: normal;
            word-break: normal;
            font-size: 17px;
            -webkit-transition: background-color .3s ease;
            transition: background-color .3s ease
        }

        ._29HP61GA_0 .MathJax_Display {
            overflow: auto
        }

        ._29HP61GA_0 .poster {
            position: fixed;
            left: -10000px;
            top: -10000px;
            overflow: hidden;
            padding: 1rem;
            background: #ececec
        }

        ._29HP61GA_0 .richcontent-pre-copy {
            font-size: 13px;
            color: #888;
            position: absolute;
            right: 1em;
            top: .5em;
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none
        }

        ._29HP61GA_0 .richcontent-pre-copy .iconfont {
            font-size: 12px;
            margin-right: .2em
        }

        ._29HP61GA_0 a {
            color: #fa8919;
            border-bottom: 1px solid #fa8919
        }

        ._29HP61GA_0 img {
            display: block;
            max-width: 100%;
            position: relative;
            left: 50%;
            -webkit-transform: translateX(-50%);
            transform: translateX(-50%);
            background-color: #eee;
            vertical-align: top;
            border-radius: 0
        }

        ._29HP61GA_0 audio,
        ._29HP61GA_0 video {
            width: 100%;
            background-color: #eee
        }

        ._29HP61GA_0 pre {
            margin-top: 16px;
            padding: 34px 0 0;
            margin-bottom: 30px;
            position: relative;
            border-radius: 6px;
            background: rgba(246, 247, 251, .749);
            border: 0
        }

        ._29HP61GA_0 pre code {
            font-size: 12px;
            font-family: Consolas, Liberation Mono, Menlo, monospace, Courier;
            display: block;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
            margin-left: 16px;
            margin-right: 16px;
            overflow-x: scroll
        }

        ._29HP61GA_0 pre code:after {
            content: "";
            height: 30px;
            width: 100%;
            display: block
        }

        ._29HP61GA_0 hr {
            border: none;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            border-top: 1px solid #f5f5f5;
            height: 1px;
            background: none
        }

        ._29HP61GA_0 h1,
        ._29HP61GA_0 h2,
        ._29HP61GA_0 h3,
        ._29HP61GA_0 h4,
        ._29HP61GA_0 h5 {
            margin-bottom: 20px;
            margin-top: 0;
            font-weight: 700
        }

        ._29HP61GA_0 b,
        ._29HP61GA_0 strong {
            font-weight: 700
        }

        ._29HP61GA_0 h1 {
            font-size: 21px
        }

        ._29HP61GA_0 h2 {
            font-size: 20px
        }

        ._29HP61GA_0 h3 {
            font-size: 19px
        }

        ._29HP61GA_0 h4 {
            font-size: 18px
        }

        ._29HP61GA_0 h5 {
            font-size: 17px
        }

        ._29HP61GA_0 center,
        ._29HP61GA_0 p {
            font-weight: 400;
            color: #353535;
            margin-top: 0;
            margin-bottom: 30px;
            word-break: break-word
        }

        ._29HP61GA_0 center {
            text-align: center
        }

        ._29HP61GA_0 blockquote {
            margin-top: 0;
            margin-bottom: 34px;
            border-left: 3px solid #e8e8e8;
            padding-left: 17px;
            color: #353535
        }

        ._29HP61GA_0 blockquote p {
            margin-top: 0;
            margin-bottom: 0
        }

        ._29HP61GA_0 ol,
        ._29HP61GA_0 ul {
            margin-bottom: 30px
        }

        ._29HP61GA_0 ol p,
        ._29HP61GA_0 ul p {
            margin-top: 0;
            margin-bottom: 0
        }

        ._29HP61GA_0 ol {
            list-style: decimal;
            margin-left: 20px
        }

        ._29HP61GA_0 ul li {
            padding-left: 17px;
            position: relative;
            margin-bottom: 10px
        }

        ._29HP61GA_0 ul li:after {
            content: "";
            height: 6px;
            width: 6px;
            border-radius: 50%;
            background: #353535;
            position: absolute;
            top: 10px;
            left: 0
        }

        ._29HP61GA_0 .orange {
            color: #fa8919
        }

        ._29HP61GA_0 .reference {
            color: #888
        }

        ._29HP61GA_0 .m-right {
            text-align: right
        }

        ._29HP61GA_0 .m-center {
            text-align: center;
            display: block
        }

        ._29HP61GA_0 .m-gray {
            color: #888
        }

        ._29HP61GA_0 .m-small {
            font-size: 15px
        }

        ._29HP61GA_0 table.hljs-ln {
            margin-bottom: 0;
            border-spacing: 0;
            border-collapse: collapse
        }

        ._29HP61GA_0 table.hljs-ln,
        ._29HP61GA_0 table.hljs-ln tbody,
        ._29HP61GA_0 table.hljs-ln td,
        ._29HP61GA_0 table.hljs-ln tr {
            -webkit-box-sizing: border-box;
            box-sizing: border-box
        }

        ._29HP61GA_0 table.hljs-ln td {
            padding: 0;
            border: 0
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-numbers {
            min-width: 15px;
            font-size: 12px;
            color: rgba(27, 31, 35, .3);
            text-align: right;
            white-space: nowrap;
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-code,
        ._29HP61GA_0 table.hljs-ln td.hljs-ln-numbers {
            font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;
            line-height: 20px;
            vertical-align: top
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-code {
            position: relative;
            padding-right: 10px;
            padding-left: 10px;
            overflow: visible;
            font-size: 13px;
            color: #666;
            word-wrap: normal;
            white-space: pre
        }

    </style>
</head>
<body>
<div class="_29HP61GA_0">
<h1>13-编译期能做些什么？一个完整的计算世界</h1>
<p>你好，我是吴咏炜。</p><p>上一讲我们简单介绍了模板的基本用法及其在泛型编程中的应用。这一讲我们来看一下模板的另外一种重要用途——编译期计算，也称作“模板元编程”。</p><h2>编译期计算</h2><p>首先，我们给出一个已经被证明的结论：C++ 模板是图灵完全的 <span class="orange">[1]</span>。这句话的意思是，使用 C++ 模板，你可以在编译期间模拟一个完整的图灵机，也就是说，可以完成任何的计算任务。</p><p>当然，这只是理论上的结论。从实际的角度，我们并不<strong>想</strong>、也不可能在编译期完成所有的计算，更不用说编译期的编程是很容易让人看不懂的——因为这并不是语言设计的初衷。即便如此，我们也还是需要了解一下模板元编程的基本概念：它仍然有一些实用的场景，并且在实际的工程中你也可能会遇到这样的代码。虽然我们在开篇就说过不要炫技，但使用模板元编程写出的代码仍然是可理解的，尤其是如果你对递归不发怵的话。</p><p>好，闲话少叙，我们仍然拿代码说话：</p><pre><code class="language-c++">template &lt;int n&gt;
struct factorial {
  static const int value =
    n * factorial&lt;n - 1&gt;::value;
};

template &lt;&gt;
struct factorial&lt;0&gt; {
  static const int value = 1;
};
</code></pre><!-- [[[read_end]]] --><p>上面定义了一个递归的阶乘函数。可以看出，它完全符合阶乘的递归定义：</p><p>$$<br>
\begin{aligned}<br>
0! &amp;= 1 \\\<br>
n! &amp;= n \times (n - 1)!<br>
\end{aligned}<br>
$$</p><p>除了顺序有特定的要求——先定义，才能特化——再加语法有点特别，代码基本上就是这个数学定义的简单映射了。</p><p>那我们怎么知道这个计算是不是在编译时做的呢？我们可以直接看编译输出。下面直接贴出对上面这样的代码加输出（<code>printf("%d\n", factorial&lt;10&gt;::value);</code>）在 x86-64 下的编译结果：</p><pre><code class="language-assembly">.LC0:
        .string "%d\n"
main:
        push    rbp
        mov     rbp, rsp
        mov     esi, 3628800
        mov     edi, OFFSET FLAT:.LC0
        mov     eax, 0
        call    printf
        mov     eax, 0
        pop     rbp
        ret
</code></pre><p>我们可以明确看到，编译结果里明明白白直接出现了常量 3628800。上面那些递归什么的，完全都没有了踪影。</p><p>如果我们传递一个负数给 <code>factorial</code> 呢？这时的结果就应该是编译期间的递归溢出。如 GCC 会报告：</p><blockquote>
<p>fatal error: template instantiation depth exceeds maximum of 900 (use -ftemplate-depth= to increase the maximum)</p>
</blockquote><p>如果把 <code>int</code> 改成 <code>unsigned</code>，不同的编译器和不同的标准选项会导致不同的结果。有些情况下错误信息完全不变，有些情况下则会报负数不能转换到 <code>unsigned</code>。通用的解决方案是使用 <code>static_assert</code>，确保参数永远不会是负数。</p><pre><code class="language-c++">template &lt;int n&gt;
struct factorial {
  static_assert(
    n &gt;= 0,
    "Arg must be non-negative");
  static const int value =
    n * factorial&lt;n - 1&gt;::value;
};
</code></pre><p>这样，当 <code>factorial</code> 接收到一个负数作为参数时，就会得到一个干脆的错误信息：</p><blockquote>
<p>error: static assertion failed: Arg must be non-negative</p>
</blockquote><p>下面我们看一些更复杂的例子。这些例子不是为了让你真的去写这样的代码，而是帮助你充分理解编译期编程的强大威力。如果这些例子你都完全掌握了，那以后碰到小的模板问题，你一定可以轻松解决，完全不在话下。</p><p>回想上面的例子，我们可以看到，要进行编译期编程，最主要的一点，是需要把计算转变成类型推导。比如，下面的模板可以代表条件语句：</p><pre><code class="language-c++">template &lt;bool cond,
          typename Then,
          typename Else&gt;
struct If;

template &lt;typename Then,
          typename Else&gt;
struct If&lt;true, Then, Else&gt; {
  typedef Then type;
};

template &lt;typename Then,
          typename Else&gt;
struct If&lt;false, Then, Else&gt; {
  typedef Else type;
};
</code></pre><p><code>If</code> 模板有三个参数，第一个是布尔值，后面两个则是代表不同分支计算的类型，这个类型可以是我们上面定义的任何一个模板实例，包括 <code>If</code> 和 <code>factorial</code>。第一个 struct 声明规定了模板的形式，然后我们不提供通用定义，而是提供了两个特化。第一个特化是真的情况，定义结果 <code>type</code> 为 <code>Then</code> 分支；第二个特化是假的情况，定义结果 <code>type</code> 为 <code>Else</code> 分支。</p><p>我们一般也需要循环：</p><pre><code class="language-c++">template &lt;bool condition,
          typename Body&gt;
struct WhileLoop;

template &lt;typename Body&gt;
struct WhileLoop&lt;true, Body&gt; {
  typedef typename WhileLoop&lt;
    Body::cond_value,
    typename Body::next_type&gt;::type
    type;
};

template &lt;typename Body&gt;
struct WhileLoop&lt;false, Body&gt; {
  typedef
    typename Body::res_type type;
};

template &lt;typename Body&gt;
struct While {
  typedef typename WhileLoop&lt;
    Body::cond_value, Body&gt;::type
    type;
};
</code></pre><p>这个循环的模板定义稍复杂点。首先，我们对循环体类型有一个约定，它必须提供一个静态数据成员，<code>cond_value</code>，及两个子类型定义，<code>res_type</code> 和 <code>next_type</code>：</p><ul>
<li><code>cond_value</code> 代表循环的条件（真或假）</li>
<li><code>res_type</code> 代表退出循环时的状态</li>
<li><code>next_type</code> 代表下面循环执行一次时的状态</li>
</ul><p>这里面比较绕的地方是用类型来代表执行状态。如果之前你没有接触过函数式编程的话，这个在初学时有困难是正常的。把例子多看两遍，自己编译、修改、把玩一下，就会渐渐理解的。</p><p>排除这个抽象性，模板的定义和 <code>If</code> 是类似的，虽然我们为方便使用，定义了两个模板。<code>WhileLoop</code> 模板有两个模板参数，同样用特化来决定走递归分支还是退出循环分支。<code>While</code> 模板则只需要循环体一个参数，方便使用。</p><p>如果你之前模板用得不多的话，还有一个需要了解的细节，就是用 <code>::</code> 取一个成员类型、并且 <code>::</code> 左边有模板参数的话，得额外加上 <code>typename</code> 关键字来标明结果是一个类型。上面循环模板的定义里就出现了多次这样的语法。MSVC 在这方面往往比较宽松，不写 <code>typename</code> 也不会报错，但这是不符合 C++ 标准的用法。</p><p>为了进行计算，我们还需要通用的代表数值的类型。下面这个模板可以通用地代表一个整数常数：</p><pre><code class="language-c++">template &lt;class T, T v&gt;
struct integral_constant {
  static const T value = v;
  typedef T value_type;
  typedef integral_constant type;
};
</code></pre><p><code>integral_constant</code> 模板同时包含了整数的类型和数值，而通过这个类型的 <code>value</code> 成员我们又可以重新取回这个数值。有了这个模板的帮忙，我们就可以进行一些更通用的计算了。下面这个模板展示了如何使用循环模板来完成从 1 加到 n 的计算：</p><pre><code class="language-c++">template &lt;int result, int n&gt;
struct SumLoop {
  static const bool cond_value =
    n != 0;
  static const int res_value =
    result;
  typedef integral_constant&lt;
    int, res_value&gt;
    res_type;
  typedef SumLoop&lt;result + n, n - 1&gt;
    next_type;
};

template &lt;int n&gt;
struct Sum {
  typedef SumLoop&lt;0, n&gt; type;
};
</code></pre><p>然后你使用 <code>While&lt;Sum&lt;10&gt;::type&gt;::type::value</code> 就可以得到 1 加到 10 的结果。虽然有点绕，但代码实质就是在编译期间进行了以下的计算：</p><pre><code class="language-c++">int result = 0;
while (n != 0) {
  result = result + n;
  n = n - 1;
}
</code></pre><p>估计现在你的头已经很晕了。但我保证，这一讲最难的部分已经过去了。实际上，到现在为止，我们讲的东西还没有离开 C++98。而我们下面几讲里很快就会讲到，如何在现代 C++ 里不使用这种麻烦的方式也能达到同样的效果。</p><h2>编译期类型推导</h2><p>C++ 标准库在 &lt;type_traits&gt; 头文件里定义了很多工具类模板，用来提取某个类型（type）在某方面的特点（trait）<span class="orange">[2]</span>。和上一节给出的例子相似，这些特点既是类型，又是常值。</p><p>为了方便地在值和类型之间转换，标准库定义了一些经常需要用到的工具类。上面描述的 <code>integral_constant</code> 就是其中一个（我的定义有所简化）。为了方便使用，针对布尔值有两个额外的类型定义：</p><pre><code class="language-c++">typedef std::integral_constant&lt;
  bool, true&gt; true_type;
typedef std::integral_constant&lt;
  bool, false&gt; false_type;
</code></pre><p>这两个标准类型 <code>true_type</code> 和 <code>false_type</code> 经常可以在函数重载中见到。有一个工具函数常常会写成下面这个样子：</p><pre><code class="language-c++">template &lt;typename T&gt;
class SomeContainer {
public:
  …
  static void destroy(T* ptr)
  {
    _destroy(ptr,
      is_trivially_destructible&lt;
        T&gt;());
  }

private:
  static void _destroy(T* ptr,
                       true_type)
  {}
  static void _destroy(T* ptr,
                       false_type)
  {
    ptr-&gt;~T();
  }
};
</code></pre><p>类似上面，很多容器类里会有一个 <code>destroy</code> 函数，通过指针来析构某个对象。为了确保最大程度的优化，常用的一个技巧就是用 <code>is_trivially_destructible</code> 模板来判断类是否是可平凡析构的——也就是说，不调用析构函数，不会造成任何资源泄漏问题。模板返回的结果还是一个类，要么是 <code>true_type</code>，要么是 <code>false_type</code>。如果要得到布尔值的话，当然使用 <code>is_trivially_destructible&lt;T&gt;::value</code> 就可以，但此处不需要。我们需要的是，使用 <code>()</code> 调用该类型的构造函数，让编译器根据数值类型来选择合适的重载。这样，在优化编译的情况下，编译器可以把不需要的析构操作彻底全部删除。</p><p>像 <code>is_trivially_destructible</code> 这样的 trait 类有很多，可以用来在模板里决定所需的特殊行为：</p><ul>
<li><code>is_array</code></li>
<li><code>is_enum</code></li>
<li><code>is_function</code></li>
<li><code>is_pointer</code></li>
<li><code>is_reference</code></li>
<li><code>is_const</code></li>
<li><code>has_virtual_destructor</code></li>
<li>…</li>
</ul><p>这些特殊行为判断可以是像上面这样用于决定不同的重载，也可以是直接用在模板参数甚至代码里（记得我们是可以直接得到布尔值的）。</p><p>除了得到布尔值和相对应的类型的 trait 模板，我们还有另外一些模板，可以用来做一些类型的转换。以一个常见的模板 <code>remove_const</code> 为例（用来去除类型里的 const 修饰），它的定义大致如下：</p><pre><code class="language-c++">template &lt;class T&gt;
struct remove_const {
  typedef T type;
};
template &lt;class T&gt;
struct remove_const&lt;const T&gt; {
  typedef T type;
};
</code></pre><p>同样，它也是利用模板的特化，针对 const 类型去掉相应的修饰。比如，如果我们对 <code>const string&amp;</code> 应用 <code>remove_const</code>，就会得到 <code>string&amp;</code>，即，<code>remove_const&lt;const string&amp;&gt;::type</code> 等价于 <code>string&amp;</code>。</p><p>这里有一个细节你要注意一下，如果对 <code>const char*</code> 应用 <code>remove_const</code> 的话，结果还是 <code>const char*</code>。原因是，<code>const char*</code> 是指向 <code>const char</code> 的指针，而不是指向 <code>char</code> 的 const 指针。如果我们对 <code>char * const</code> 应用 <code>remove_const</code> 的话，还是可以得到 <code>char*</code> 的。</p><h3>简易写法</h3><p>如果你觉得写 <code>is_trivially_destructible&lt;T&gt;::value</code> 和 <code>remove_const&lt;T&gt;::type</code> 非常啰嗦的话，那你绝不是一个人。在当前的 C++ 标准里，前者有增加 <code>_v</code> 的编译时常量，后者有增加 <code>_t</code> 的类型别名：</p><pre><code class="language-c++">template &lt;class T&gt;
inline constexpr bool
  is_trivially_destructible_v =
    is_trivially_destructible&lt;
      T&gt;::value;
</code></pre><pre><code class="language-c++">template &lt;class T&gt;
using remove_const_t =
  typename remove_const&lt;T&gt;::type;
</code></pre><p>至于什么是 <code>constexpr</code>，我们会单独讲。<code>using</code> 是现代 C++ 的新语法，功能大致与 <code>typedef</code> 相似，但 <code>typedef</code> 只能针对某个特定的类型，而 <code>using</code> 可以生成别名模板。目前我们只需要知道，在你需要 trait 模板的结果数值和类型时，使用带 <code>_v</code> 和 <code>_t</code> 后缀的模板可能会更方便，尤其是带 <code>_t</code> 后缀的类型转换模板。</p><h2>通用的 fmap 函数模板</h2><p>你应当多多少少听到过 map-reduce。抛开其目前在大数据应用中的具体方式不谈，从概念本源来看，map <span class="orange">[3]</span> 和 reduce <span class="orange">[4]</span> 都来自函数式编程。下面我们演示一个 map 函数（当然，在 C++ 里它的名字就不能叫 <code>map</code> 了），其中用到了目前为止我们学到的多个知识点：</p><pre><code class="language-c++">template &lt;
  template &lt;typename, typename&gt;
  class OutContainer = vector,
  typename F, class R&gt;
auto fmap(F&amp;&amp; f, R&amp;&amp; inputs)
{
  typedef decay_t&lt;decltype(
    f(*inputs.begin()))&gt;
    result_type;
  OutContainer&lt;
    result_type,
    allocator&lt;result_type&gt;&gt;
    result;
  for (auto&amp;&amp; item : inputs) {
    result.push_back(f(item));
  }
  return result;
}
</code></pre><p>我们：</p><ul>
<li>用 <code>decltype</code> 来获得用 <code>f</code> 来调用 <code>inputs</code> 元素的类型（参考第 8 讲）；</li>
<li>用 <code>decay_t</code> 来把获得的类型变成一个普通的值类型；</li>
<li>缺省使用 <code>vector</code> 作为返回值的容器，但可以通过模板参数改为其他容器；</li>
<li>使用基于范围的 for 循环来遍历 <code>inputs</code>，对其类型不作其他要求（参考第 7 讲）；</li>
<li>存放结果的容器需要支持 <code>push_back</code> 成员函数（参考第 4 讲）。</li>
</ul><p>下面的代码可以验证其功能：</p><pre><code class="language-c++">vector&lt;int&gt; v{1, 2, 3, 4, 5};
int add_1(int x)
{
    return x + 1;
}

auto result = fmap(add_1, v);
</code></pre><p>在 <code>fmap</code> 执行之后，我们会在 <code>result</code> 里得到一个新容器，其内容是 2, 3, 4, 5, 6。</p><h2>内容小结</h2><p>本讲我们介绍了模板元编程的基本概念和例子，其本质是<strong>把计算过程用编译期的类型推导和类型匹配表达出来</strong>；然后介绍 type traits 及其基本用法；最后我们演示了一个简单的高阶函数 map，其实现中用到了我们目前已经讨论过的一些知识点。</p><h2>课后思考</h2><p>这一讲的内容可能有点烧脑，请你自行实验一下例子，并找一两个简单的算法用模板元编程的方法实现一下，看看能不能写出来。</p><p>如果有什么特别想法的话，欢迎留言和我分享交流。</p><h2><span class="reference">参考资料</span></h2><p><span class="reference">[1] Todd L. Veldhuizen, “C++ templates are Turing complete”. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.3670</a> </span></p><p><span class="reference">[2] cppreference.com, “Standard library header &lt;type_traits&gt;”. <a href="https://en.cppreference.com/w/cpp/header/type_traits">https://en.cppreference.com/w/cpp/header/type_traits</a> </span></p><p><span class="reference">[2a] cppreference.com, “标准库头文件 &lt;type_traits&gt;”. <a href="https://zh.cppreference.com/w/cpp/header/type_traits">https://zh.cppreference.com/w/cpp/header/type_traits</a> </span></p><p><span class="reference">[3] Wikipedia, “Map (higher-order function)”. <a href="https://en.wikipedia.org/wiki/Map_(higher-order_function)">https://en.wikipedia.org/wiki/Map_(higher-order_function)</a> </span></p><p><span class="reference">[4] Wikipedia, “Fold (higher-order function)”. <a href="https://en.wikipedia.org/wiki/Fold_(higher-order_function)">https://en.wikipedia.org/wiki/Fold_(higher-order_function)</a> </span></p><h2>精选留言：</h2>
        <ul>
        
<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            zhang  2019-12-26 20:12:17
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            您好，我想问一个mutex相关的问题，虽然这部分内容以后会讲，但我现在工作中有一个疑问，麻烦您看一下，谢谢。<br>代码简写如下：<br>class Mutex {<br>public:<br>    pthread_mutex_t mutex;<br>    Mutex():mutex(PTHREAD_MUTEX_INITIALIZER) {}<br>    void lock() {<br>        pthread_mutex_lock(&amp;mutex);<br>    }<br>    void unlock() {<br>        pthread_mutex_unlock(&amp;mutex);<br>    }<br>};<br>class Cond {<br>public:<br>    pthread_cond_t cond;<br>    Cond():cond(PTHREAD_COND_INITIALIZER) {}<br>    void signal() {<br>        pthread_cond_signal(&amp;cond);<br>    }<br>    void broadcast() {<br>        pthread_cond_broadcast(&amp;cond);<br>    }<br>    void wait(Mutex &amp;mutex) {<br>        pthread_cond_wait(&amp;cond, &amp;mutex.mutex);<br>    }<br>};<br>class ScopeLock {<br>    Mutex &amp;mutex;<br>public:<br>    ScopeLock(CanMutex &amp;_mutex):mutex(_mutex) {<br>        mutex.lock();<br>    };<br>    ~ScopeLock() {<br>        mutex.unlock();<br>    };<br>};<br><br>class Client<br>{<br>public:<br>    Mutex inter_mutex;<br>    Mutex mutex;<br>    Cond cond;<br>    bool pending;<br>    Client():pending(false){}<br>    ~Client(){}<br>    void Lock() {<br>        mutex.lock();<br>    }<br>    void Unlock() {<br>        mutex.unlock();<br>    }<br>    void sendData() {<br>        const ScopeLock inter_protect(inter_mutex);<br>        const ScopeLock protect(mutex);<br><br>        &#47;&#47;send_to_server();<br><br>        while (!pending) {<br>            cond.wait(mutex);<br>        }<br>        pending = false;<br>    }<br>    void recvData() {<br>        const ScopeLock protect(mutex);<br>        pending = true;<br>        cond.signal();<br>    }<br>};<br>我有几个线程会执行同一个Client对象的sendData函数，有一个线程执行Client对象的recvData函数。我主要想问我几个sendData线程需要同步执行，执行完一个sendData发送后，再执行另一个sendData。那么我在sendData函数最开始加整个函数范围的锁const ScopeLock inter_protect(inter_mutex);，是否可以这样做？谢谢！ 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-27 09:44:54</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">对你的业务场景不熟悉，随便评论几句。<br><br>・C++11 里有现成的 mutex、condition_variable 和 unique_lock。<br>・Client::Lock 和 Client::Unlock 似乎没有用处。<br>・变量 pending 的命名让人困惑：收到数据了，“挂起”标志被设为真，然后发送数据就能继续往下执行了？连续两次 sendData 中间必须有一次 recvData 才行，而且 sendData 里的等待是在发送之后？这块感觉有问题。<br>・inter_mutex 和 inter_protect 本身目前没有看出问题。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            安静的雨  2019-12-25 20:55:53
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            模版编程很有趣，期待老师的更新。 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-26 12:53:49</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">觉得有趣就好，这个我们要讲上好几讲的。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            总统老唐  2019-12-25 17:49:17
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            记得吴老师之前预告过，这一节可能会比较难，确实被难住了。在第一个 If 模板这里就被卡住了，老师能给个简单的例子来说明这个 If 模板该如何使用么？ 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-25 22:20:42</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">下面的函数和模板是基本等价的：<br><br>int foo(int n)<br>{<br>  if (n == 2 || n == 3 || n == 5) {<br>    return 1;<br>  } else {<br>    return 2;<br>  }<br>}<br><br>template &lt;int n&gt;<br>struct Foo {<br>  typedef typename If&lt;<br>    (n == 2 || n == 3 || n == 5),<br>    integral_constant&lt;int, 1&gt;,<br>    integral_constant&lt;int, 2&gt;&gt;::type<br>    type;<br>};<br><br>你可以输出 foo(3)，也可以输出 Foo&lt;3&gt;::type::value。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            禾桃  2019-12-25 15:57:24
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            脑壳儿疼的兄弟姐妹们，我这有个小偏方， 哈哈<br><br>While&lt; Sum&lt;2&gt;::type &gt;::type::value 实例化(instantiation)过程<br>--&gt; While&lt; SumLoop&lt;0, 2&gt; &gt;::type::value<br>--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;&gt;::type::value<br>--&gt; WhileLoop&lt;true, SumLoop&lt;0, 2&gt;&gt;::type::value<br><br>--&gt; WhileLoop&lt;SumLoop&lt;0, 2&gt;::cond_value, SumLoop&lt;0, 2&gt;::next_type&gt;::type::value<br>--&gt; WhileLoop&lt;true, SumLoop&lt;2, 1&gt;&gt;::type::value<br><br>--&gt; WhileLoop&lt;SumLoop&lt;2, 1&gt;::cond_value, SumLoop&lt;2, 1&gt;::next_type&gt;::type::value<br>--&gt; WhileLoop&lt;true, SumLoop&lt;3, 0&gt;&gt;::type::value<br><br>--&gt; WhileLoop&lt;SumLoop&lt;3, 0&gt;::cond_value, SumLoop&lt;3, 0&gt;::next_type&gt;::type::value<br>--&gt; WhileLoop&lt;false, SumLoop&lt;3, -1&gt;&gt;::type::value<br><br>--&gt; SumLoop&lt;3, -1&gt;::res_type::value<br><br>--&gt;integral_constant&lt;int, 3&gt;::value<br>--&gt;3 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-25 20:03:39</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">对，对于模板，就是要在脑子里或纸上、电脑上把它展开……☺️</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            小一日一  2019-12-25 11:45:43
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            #include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;type_traits&gt;<br><br>using namespace std;<br><br>template&lt; class T &gt;<br>using decay_t = typename decay&lt;T&gt;::type;<br><br>template &lt; template &lt;typename, typename&gt; class OutContainer = vector,<br>           typename F, class R&gt;<br>auto fmap(F&amp;&amp; f, R&amp;&amp; inputs)<br>{<br>    typedef decay_t&lt;decltype( f(*inputs.begin()))&gt; result_type;<br>    OutContainer&lt; result_type, allocator&lt;result_type&gt;&gt; result;<br>    for (auto&amp;&amp; item : inputs) {<br>        result.push_back(f(item));<br>    }<br>    return result;<br>}<br><br>int add_1(int x)<br>{<br>    return x + 1;<br>}<br><br>int main()<br>{<br>    vector&lt;int&gt; v{1, 2, 3, 4, 5};<br><br>    auto result = fmap(add_1, v);<br><br>    for (auto &amp;&amp;v : result) {<br>        cout &lt;&lt; v &lt;&lt; endl;<br>    }<br>}<br><br>用g++ 4.8.5 带std=c++11参数编译能通过并正确运行，但是有warning:<br>13_5.cc:12:28: warning: ‘fmap’ function uses ‘auto’ type specifier without trailing return type [enabled by default] auto fmap(F&amp;&amp; f, R&amp;&amp; inputs)<br><br>请问老师如何加尾置返回类型消除warning? 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-25 20:02:21</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">试试 c++1y、c++14 等标准选项了。这个 GCC 太老了……我要求 C++17、GCC 7 的。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            李义盛  2019-12-25 09:40:26
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            一到模板就处于看不懂状态了。 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-25 20:00:19</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">拿纸笔来展开试试？实际上就是一种展开而已。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            禾桃  2019-12-25 08:13:23
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            “常用的一个技巧就是用 is_trivially_destructible 模板来判断类是否是可平凡析构的——也就是说，不调用析构函数，不会造成任何资源泄漏问题。”<br><br>麻烦解释一下，<br>#1 这个类模版是如何识别“，不调用析构函数，不会造成任何资源泄漏问题”？ 这的资源包括new的堆内存吗？<br>#2 trivially这个词总是觉得很难理解，C++里，使用这个词的目的，到底是什么？ 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-25 09:24:05</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">1 是有点编译器魔法的。如果你有析构函数，或者你没有析构函数但有个非 POD 数据成员，is_trivially_destructible 就不成立了。<br><br>2 trivial 是很常见的数学术语，没什么特别的。见：<br><br>https:&#47;&#47;baike.baidu.com&#47;item&#47;%E5%B9%B3%E5%87%A1&#47;16739977<br>https:&#47;&#47;zh.wikipedia.org&#47;wiki&#47;%E5%B9%B3%E5%87%A1_(%E6%95%B8%E5%AD%B8)<br>https:&#47;&#47;en.wikipedia.org&#47;wiki&#47;Triviality_(mathematics)</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            hello world  2019-12-25 08:11:43
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            一直对模板元编程感兴趣，但总是搞不明白，今天学习很有收获，特别是最后的fmap，感谢老师，记得模板编程还有policy之类的东西，老师之后在编译期这方面还会更详细讲解吗 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-25 09:36:17</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">编译期要连续讲到第 18 讲，甚至之后还会有提到的机会。你喜欢那是最好了。我是怕很多人会被编译期编程吓退呢。😅<br><br>policy 这个概念不单独讲，但我觉得在讨论了使用常数来对模板进行特化之后，这个概念应该没有特别之处。我们的例子倒是会有标准库提供的 policy。😁</div>
</div>
            
    </div>
</li>
            </ul>
</div>
</body>
</html>