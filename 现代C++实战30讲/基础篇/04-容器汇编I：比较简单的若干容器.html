<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>04-容器汇编I：比较简单的若干容器</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <style>
        html {
            color: #333;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-rendering: optimizelegibility;
            font-family: Helvetica Neue, PingFang SC, Verdana, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, sans-serif
        }

        html.borderbox *,
        html.borderbox :after,
        html.borderbox :before {
            box-sizing: border-box
        }

        article,
        aside,
        blockquote,
        body,
        button,
        code,
        dd,
        details,
        dl,
        dt,
        fieldset,
        figcaption,
        figure,
        footer,
        form,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        header,
        hr,
        input,
        legend,
        li,
        menu,
        nav,
        ol,
        p,
        pre,
        section,
        td,
        textarea,
        th,
        ul {
            margin: 0;
            padding: 0
        }

        article,
        aside,
        details,
        figcaption,
        figure,
        footer,
        header,
        menu,
        nav,
        section {
            display: block
        }

        audio,
        canvas,
        video {
            display: inline-block
        }

        body,
        button,
        input,
        select,
        textarea {
            font: 300 1em/1.8 PingFang SC, Lantinghei SC, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, Helvetica, sans-serif
        }

        button::-moz-focus-inner,
        input::-moz-focus-inner {
            padding: 0;
            border: 0
        }

        table {
            border-collapse: collapse;
            border-spacing: 0
        }

        fieldset,
        img {
            border: 0
        }

        blockquote {
            position: relative;
            color: #999;
            font-weight: 400;
            border-left: 1px solid #1abc9c;
            padding-left: 1em;
            margin: 1em 3em 1em 2em
        }

        @media only screen and (max-width: 640px) {
            blockquote {
                margin: 1em 0
            }
        }

        abbr,
        acronym {
            border-bottom: 1px dotted;
            font-variant: normal
        }

        abbr {
            cursor: help
        }

        del {
            text-decoration: line-through
        }

        address,
        caption,
        cite,
        code,
        dfn,
        em,
        th,
        var {
            font-style: normal;
            font-weight: 400
        }

        ol,
        ul {
            list-style: none
        }

        caption,
        th {
            text-align: left
        }

        q:after,
        q:before {
            content: ""
        }

        sub,
        sup {
            font-size: 75%;
            line-height: 0;
            position: relative
        }

        :root sub,
        :root sup {
            vertical-align: baseline
        }

        sup {
            top: -.5em
        }

        sub {
            bottom: -.25em
        }

        a {
            color: #1abc9c
        }

        a:hover {
            text-decoration: underline
        }

        .typo a {
            border-bottom: 1px solid #1abc9c
        }

        .typo a:hover {
            border-bottom-color: #555;
            color: #555
        }

        .typo a:hover,
        a,
        ins {
            text-decoration: none
        }

        .typo-u,
        u {
            text-decoration: underline
        }

        mark {
            background: #fffdd1;
            border-bottom: 1px solid #ffedce;
            padding: 2px;
            margin: 0 5px
        }

        code,
        pre,
        pre tt {
            font-family: Courier, Courier New, monospace
        }

        pre {
            background: hsla(0, 0%, 97%, .7);
            border: 1px solid #ddd;
            padding: 1em 1.5em;
            display: block;
            -webkit-overflow-scrolling: touch
        }

        hr {
            border: none;
            border-bottom: 1px solid #cfcfcf;
            margin-bottom: .8em;
            height: 10px
        }

        .typo-small,
        figcaption,
        small {
            font-size: .9em;
            color: #888
        }

        b,
        strong {
            font-weight: 700;
            color: #000
        }

        [draggable] {
            cursor: move
        }

        .clearfix:after,
        .clearfix:before {
            content: "";
            display: table
        }

        .clearfix:after {
            clear: both
        }

        .clearfix {
            zoom: 1
        }

        .textwrap,
        .textwrap td,
        .textwrap th {
            word-wrap: break-word;
            word-break: break-all
        }

        .textwrap-table {
            table-layout: fixed
        }

        .serif {
            font-family: Palatino, Optima, Georgia, serif
        }

        .typo-dl,
        .typo-form,
        .typo-hr,
        .typo-ol,
        .typo-p,
        .typo-pre,
        .typo-table,
        .typo-ul,
        .typo dl,
        .typo form,
        .typo hr,
        .typo ol,
        .typo p,
        .typo pre,
        .typo table,
        .typo ul,
        blockquote {
            margin-bottom: 1rem
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-family: PingFang SC, Helvetica Neue, Verdana, Microsoft Yahei, Hiragino Sans GB, Microsoft Sans Serif, WenQuanYi Micro Hei, sans-serif;
            color: #000;
            line-height: 1.35
        }

        .typo-h1,
        .typo-h2,
        .typo-h3,
        .typo-h4,
        .typo-h5,
        .typo-h6,
        .typo h1,
        .typo h2,
        .typo h3,
        .typo h4,
        .typo h5,
        .typo h6 {
            margin-top: 1.2em;
            margin-bottom: .6em;
            line-height: 1.35
        }

        .typo-h1,
        .typo h1 {
            font-size: 2em
        }

        .typo-h2,
        .typo h2 {
            font-size: 1.8em
        }

        .typo-h3,
        .typo h3 {
            font-size: 1.6em
        }

        .typo-h4,
        .typo h4 {
            font-size: 1.4em
        }

        .typo-h5,
        .typo-h6,
        .typo h5,
        .typo h6 {
            font-size: 1.2em
        }

        .typo-ul,
        .typo ul {
            margin-left: 1.3em;
            list-style: disc
        }

        .typo-ol,
        .typo ol {
            list-style: decimal;
            margin-left: 1.9em
        }

        .typo-ol ol,
        .typo-ol ul,
        .typo-ul ol,
        .typo-ul ul,
        .typo li ol,
        .typo li ul {
            margin-bottom: .8em;
            margin-left: 2em
        }

        .typo-ol ul,
        .typo-ul ul,
        .typo li ul {
            list-style: circle
        }

        .typo-table td,
        .typo-table th,
        .typo table caption,
        .typo table td,
        .typo table th {
            border: 1px solid #ddd;
            padding: .5em 1em;
            color: #666
        }

        .typo-table th,
        .typo table th {
            background: #fbfbfb
        }

        .typo-table thead th,
        .typo table thead th {
            background: hsla(0, 0%, 95%, .7)
        }

        .typo table caption {
            border-bottom: none
        }

        .typo-input,
        .typo-textarea {
            -webkit-appearance: none;
            border-radius: 0
        }

        .typo-em,
        .typo em,
        caption,
        legend {
            color: #000;
            font-weight: inherit
        }

        .typo-em {
            position: relative
        }

        .typo-em:after {
            position: absolute;
            top: .65em;
            left: 0;
            width: 100%;
            overflow: hidden;
            white-space: nowrap;
            content: "\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB\30FB"
        }

        .typo img {
            max-width: 100%
        }

        .common-content {
            font-weight: 400;
            color: #353535;
            line-height: 1.75rem;
            white-space: normal;
            word-break: normal;
            font-size: 1rem
        }

        .common-content img {
            display: block;
            max-width: 100%;
            background-color: #eee
        }

        .common-content audio,
        .common-content video {
            width: 100%;
            background-color: #eee
        }

        .common-content center,
        .common-content font {
            margin-top: 1rem;
            display: inline-block
        }

        .common-content center {
            width: 100%
        }

        .common-content pre {
            margin-top: 1rem;
            padding-left: 0;
            padding-right: 0;
            position: relative;
            overflow: hidden
        }

        .common-content pre code {
            font-size: .8rem;
            font-family: Consolas, Liberation Mono, Menlo, monospace, Courier;
            display: block;
            width: 100%;
            box-sizing: border-box;
            padding-left: 1rem;
            padding-right: 1rem;
            overflow-x: auto
        }

        .common-content hr {
            border: none;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            border-top: 1px solid #f5f5f5;
            height: 1px;
            background: none
        }

        .common-content b,
        .common-content h1,
        .common-content h2,
        .common-content h3,
        .common-content h4,
        .common-content h5,
        .common-content strong {
            font-weight: 700
        }

        .common-content h1,
        .common-content h2 {
            font-size: 1.125rem;
            margin-bottom: .45rem
        }

        .common-content h3,
        .common-content h4,
        .common-content h5 {
            font-size: 1rem;
            margin-bottom: .45rem
        }

        .common-content p {
            font-weight: 400;
            color: #353535;
            margin-top: .15rem
        }

        .common-content .orange {
            color: #ff5a05
        }

        .common-content .reference {
            font-size: 1rem;
            color: #888
        }

        .custom-rich-content h1 {
            margin-top: 0;
            font-weight: 400;
            font-size: 15.25px;
            border-bottom: 1px solid #eee;
            line-height: 2.8
        }

        .custom-rich-content li,
        .custom-rich-content p {
            font-size: 14px;
            color: #888;
            line-height: 1.6
        }

        table.hljs-ln {
            margin-bottom: 0;
            border-spacing: 0;
            border-collapse: collapse
        }

        table.hljs-ln,
        table.hljs-ln tbody,
        table.hljs-ln td,
        table.hljs-ln tr {
            box-sizing: border-box
        }

        table.hljs-ln td {
            padding: 0;
            border: 0
        }

        table.hljs-ln td.hljs-ln-numbers {
            min-width: 15px;
            color: rgba(27, 31, 35, .3);
            text-align: right;
            white-space: nowrap;
            cursor: pointer;
            user-select: none
        }

        table.hljs-ln td.hljs-ln-code,
        table.hljs-ln td.hljs-ln-numbers {
            font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;
            font-size: 12px;
            line-height: 20px;
            vertical-align: top
        }

        table.hljs-ln td.hljs-ln-code {
            position: relative;
            padding-right: 10px;
            padding-left: 10px;
            overflow: visible;
            color: #24292e;
            word-wrap: normal;
            white-space: pre
        }

        video::-webkit-media-controls {
            overflow: hidden !important
        }

        video::-webkit-media-controls-enclosure {
            width: calc(100% + 32px);
            margin-left: auto
        }

        ._29HP61GA_0 {
            max-width:800px;
            margin:0 auto;
            margin-bottom: 20px;
            font-weight: 400;
            color: #353535;
            line-height: 1.76;
            white-space: normal;
            word-break: normal;
            font-size: 17px;
            -webkit-transition: background-color .3s ease;
            transition: background-color .3s ease
        }

        ._29HP61GA_0 .MathJax_Display {
            overflow: auto
        }

        ._29HP61GA_0 .poster {
            position: fixed;
            left: -10000px;
            top: -10000px;
            overflow: hidden;
            padding: 1rem;
            background: #ececec
        }

        ._29HP61GA_0 .richcontent-pre-copy {
            font-size: 13px;
            color: #888;
            position: absolute;
            right: 1em;
            top: .5em;
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none
        }

        ._29HP61GA_0 .richcontent-pre-copy .iconfont {
            font-size: 12px;
            margin-right: .2em
        }

        ._29HP61GA_0 a {
            color: #fa8919;
            border-bottom: 1px solid #fa8919
        }

        ._29HP61GA_0 img {
            display: block;
            max-width: 100%;
            position: relative;
            left: 50%;
            -webkit-transform: translateX(-50%);
            transform: translateX(-50%);
            background-color: #eee;
            vertical-align: top;
            border-radius: 0
        }

        ._29HP61GA_0 audio,
        ._29HP61GA_0 video {
            width: 100%;
            background-color: #eee
        }

        ._29HP61GA_0 pre {
            margin-top: 16px;
            padding: 34px 0 0;
            margin-bottom: 30px;
            position: relative;
            border-radius: 6px;
            background: rgba(246, 247, 251, .749);
            border: 0
        }

        ._29HP61GA_0 pre code {
            font-size: 12px;
            font-family: Consolas, Liberation Mono, Menlo, monospace, Courier;
            display: block;
            -webkit-box-sizing: border-box;
            box-sizing: border-box;
            margin-left: 16px;
            margin-right: 16px;
            overflow-x: scroll
        }

        ._29HP61GA_0 pre code:after {
            content: "";
            height: 30px;
            width: 100%;
            display: block
        }

        ._29HP61GA_0 hr {
            border: none;
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            border-top: 1px solid #f5f5f5;
            height: 1px;
            background: none
        }

        ._29HP61GA_0 h1,
        ._29HP61GA_0 h2,
        ._29HP61GA_0 h3,
        ._29HP61GA_0 h4,
        ._29HP61GA_0 h5 {
            margin-bottom: 20px;
            margin-top: 0;
            font-weight: 700
        }

        ._29HP61GA_0 b,
        ._29HP61GA_0 strong {
            font-weight: 700
        }

        ._29HP61GA_0 h1 {
            font-size: 21px
        }

        ._29HP61GA_0 h2 {
            font-size: 20px
        }

        ._29HP61GA_0 h3 {
            font-size: 19px
        }

        ._29HP61GA_0 h4 {
            font-size: 18px
        }

        ._29HP61GA_0 h5 {
            font-size: 17px
        }

        ._29HP61GA_0 center,
        ._29HP61GA_0 p {
            font-weight: 400;
            color: #353535;
            margin-top: 0;
            margin-bottom: 30px;
            word-break: break-word
        }

        ._29HP61GA_0 center {
            text-align: center
        }

        ._29HP61GA_0 blockquote {
            margin-top: 0;
            margin-bottom: 34px;
            border-left: 3px solid #e8e8e8;
            padding-left: 17px;
            color: #353535
        }

        ._29HP61GA_0 blockquote p {
            margin-top: 0;
            margin-bottom: 0
        }

        ._29HP61GA_0 ol,
        ._29HP61GA_0 ul {
            margin-bottom: 30px
        }

        ._29HP61GA_0 ol p,
        ._29HP61GA_0 ul p {
            margin-top: 0;
            margin-bottom: 0
        }

        ._29HP61GA_0 ol {
            list-style: decimal;
            margin-left: 20px
        }

        ._29HP61GA_0 ul li {
            padding-left: 17px;
            position: relative;
            margin-bottom: 10px
        }

        ._29HP61GA_0 ul li:after {
            content: "";
            height: 6px;
            width: 6px;
            border-radius: 50%;
            background: #353535;
            position: absolute;
            top: 10px;
            left: 0
        }

        ._29HP61GA_0 .orange {
            color: #fa8919
        }

        ._29HP61GA_0 .reference {
            color: #888
        }

        ._29HP61GA_0 .m-right {
            text-align: right
        }

        ._29HP61GA_0 .m-center {
            text-align: center;
            display: block
        }

        ._29HP61GA_0 .m-gray {
            color: #888
        }

        ._29HP61GA_0 .m-small {
            font-size: 15px
        }

        ._29HP61GA_0 table.hljs-ln {
            margin-bottom: 0;
            border-spacing: 0;
            border-collapse: collapse
        }

        ._29HP61GA_0 table.hljs-ln,
        ._29HP61GA_0 table.hljs-ln tbody,
        ._29HP61GA_0 table.hljs-ln td,
        ._29HP61GA_0 table.hljs-ln tr {
            -webkit-box-sizing: border-box;
            box-sizing: border-box
        }

        ._29HP61GA_0 table.hljs-ln td {
            padding: 0;
            border: 0
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-numbers {
            min-width: 15px;
            font-size: 12px;
            color: rgba(27, 31, 35, .3);
            text-align: right;
            white-space: nowrap;
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-code,
        ._29HP61GA_0 table.hljs-ln td.hljs-ln-numbers {
            font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, Courier, monospace;
            line-height: 20px;
            vertical-align: top
        }

        ._29HP61GA_0 table.hljs-ln td.hljs-ln-code {
            position: relative;
            padding-right: 10px;
            padding-left: 10px;
            overflow: visible;
            font-size: 13px;
            color: #666;
            word-wrap: normal;
            white-space: pre
        }

    </style>
</head>
<body>
<div class="_29HP61GA_0">
<h1>04-容器汇编I：比较简单的若干容器</h1>
<p>你好，我是吴咏炜。</p><p>上几讲我们学习了 C++ 的资源管理和值类别。今天我们换一个话题，来看一下 C++ 里的容器。</p><p>关于容器，已经存在不少的学习资料了。在 cppreference 上有很完备的参考资料（<span class="orange">[1]</span>）。今天我们采取一种非正规的讲解方式，尽量不重复已有的参考资料，而是让你加深对于重要容器的理解。</p><p>对于容器，学习上的一个麻烦点是你无法直接输出容器的内容——如果你定义了一个 <code>vector&lt;int&gt; v</code>，你是没法简单输出 <code>v</code> 的内容的。有人也许会说用 <code>copy(v.begin(), v.end(), ostream_iterator(…))</code>，可那既啰嗦，又对像 <code>map</code> 或 <code>vector&lt;vector&lt;…&gt;&gt;</code> 这样的复杂类型无效。因此，我们需要一个更好用的工具。在此，我向你大力推荐 xeus-cling <span class="orange">[2]</span>。它的便利性无与伦比——你可以直接在浏览器里以交互的方式运行代码，不需要本机安装任何编译器（点击“Trying it online”下面的 binder 链接）。下面是在线运行的一个截图：</p><p><img src="https://static001.geekbang.org/resource/image/71/ca/7199bb5b1394fe1aa9f91b850c309eca.png" alt=""></p><p>xeus-cling 也可以在本地安装。对于使用 Linux 的同学，安装应当是相当便捷的。有兴趣的话，使用其他平台的同学也可以尝试一下。</p><p>如果你既没有本地运行的条件，也不方便远程使用互联网来运行代码，我个人还为本专栏写了一个小小的工具 <span class="orange">[3]</span>。在你的代码中包含这个头文件，也可以方便地得到类似于上面的输出。示例代码如下所示：</p><!-- [[[read_end]]] --><pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include "output_container.h"

using namespace std;

int main()
{
  map&lt;int, int&gt; mp{
    {1, 1}, {2, 4}, {3, 9}};
  cout &lt;&lt; mp &lt;&lt; endl;
  vector&lt;vector&lt;int&gt;&gt; vv{
    {1, 1}, {2, 4}, {3, 9}};
  cout &lt;&lt; vv &lt;&lt; endl;
}
</code></pre><p>我们会得到下面的输出：</p><blockquote>
<p><code>{ 1 =&gt; 1, 2 =&gt; 4, 3 =&gt; 9 }</code><br>
<code>{ { 1, 1 }, { 2, 4 }, { 3, 9 } }</code></p>
</blockquote><p>这个代码中用到了很多我们目前专栏还没有讲的知识，所以你暂且不用关心它的实现原理。如果你能看得懂这个代码，那就太棒了。如果你看不懂，唔，不急，慢慢来，你会明白的。</p><p>工具在手，天下我有。下面我们正式开讲容器篇。</p><h2>string</h2><p><code>string</code> 一般并不被认为是一个 C++ 的容器。但鉴于其和容器有很多共同点，我们先拿 <code>string</code> 类来开说。</p><p><code>string</code> 是模板 <code>basic_string</code> 对于 <code>char</code> 类型的特化，可以认为是一个只存放字符 <code>char</code> 类型数据的容器。“真正”的容器类与 <code>string</code> 的最大不同点是里面可以存放任意类型的对象。</p><p>跟其他大部分容器一样， <code>string</code> 具有下列成员函数：</p><ul>
<li><code>begin</code> 可以得到对象起始点</li>
<li><code>end</code> 可以得到对象的结束点</li>
<li><code>empty</code> 可以得到容器是否为空</li>
<li><code>size</code> 可以得到容器的大小</li>
<li><code>swap</code> 可以和另外一个容器交换其内容</li>
</ul><p>（对于不那么熟悉容器的人，需要知道 C++ 的 <code>begin</code> 和 <code>end</code> 是半开半闭区间：在容器非空时，<code>begin</code> 指向一个第一个元素，而 <code>end</code> 指向最后一个元素后面的位置；在容器为空时，<code>begin</code> 等于 <code>end</code>。在 <code>string</code> 的情况下，由于考虑到和 C 字符串的兼容，<code>end</code> 指向代表字符串结尾的 <code>\0</code> 字符。）</p><p>上面就几乎是所有容器的共同点了。也就是说：</p><ul>
<li>容器都有开始和结束点</li>
<li>容器会记录其状态是否非空</li>
<li>容器有大小</li>
<li>容器支持交换</li>
</ul><p>当然，这只是容器的“共同点”而已。每个容器都有其特殊的用途。</p><p><code>string</code> 的内存布局大致如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/ee/62/eec393f933220a9998b7235c8acc1862.png" alt=""></p><p>下面你会看到，不管是内存布局，还是成员函数，<code>string</code> 和 <code>vector</code> 是非常相似的。</p><p><code>string</code> 当然是为了存放字符串。和简单的 C 字符串不同：</p><ul>
<li><code>string</code> 负责自动维护字符串的生命周期</li>
<li><code>string</code> 支持字符串的拼接操作（如之前说过的 <code>+</code> 和 <code>+=</code>）</li>
<li><code>string</code> 支持字符串的查找操作（如 <code>find</code> 和 <code>rfind</code>）</li>
<li><code>string</code> 支持从 <code>istream</code> 安全地读入字符串（使用 <code>getline</code>）</li>
<li><code>string</code> 支持给期待 <code>const char*</code> 的接口传递字符串内容（使用 <code>c_str</code>）</li>
<li><code>string</code> 支持到数字的互转（<code>stoi</code> 系列函数和 <code>to_string</code>）</li>
<li>等等</li>
</ul><p>推荐你在代码中尽量使用 <code>string</code> 来管理字符串。不过，对于对外暴露的接口，情况有一点复杂。我一般不建议在接口中使用 <code>const string&amp;</code>，除非确知调用者已经持有 <code>string</code>：如果函数里不对字符串做复杂处理的话，使用 <code>const char*</code> 可以避免在调用者只有 C 字符串时编译器自动构造 <code>string</code>，这种额外的构造和析构代价并不低。反过来，如果实现较为复杂、希望使用 <code>string</code> 的成员函数的话，那就应该考虑下面的策略：</p><ul>
<li>如果不修改字符串的内容，使用 <code>const string&amp;</code> 或 C++17 的 <code>string_view</code> 作为参数类型。后者是最理想的情况，因为即使在只有 C 字符串的情况，也不会引发不必要的内存复制。</li>
<li>如果需要在函数内修改字符串内容、但不影响调用者的该字符串，使用 <code>string</code> 作为参数类型（自动拷贝）。</li>
<li>如果需要改变调用者的字符串内容，使用 <code>string&amp;</code> 作为参数类型（通常不推荐）。</li>
</ul><p>估计大部分同学对 <code>string</code> 已经很熟悉了。我们在此只给出一个非常简单的小例子：</p><pre><code class="language-c++">string name;
cout &lt;&lt; "What's your name? ";
getline(cin, name);
cout &lt;&lt; "Nice to meet you, " &lt;&lt; name
     &lt;&lt; "!\n";
</code></pre><h2>vector</h2><p><code>vector</code> 应该是最常用的容器了。它的名字“向量”来源于数学术语，但在实际应用中，我们把它当成动态数组更为合适。它基本相当于 Java 的 <code>ArrayList</code> 和 Python 的 <code>list</code>。</p><p>和 <code>string</code> 相似，<code>vector</code> 的成员在内存里连续存放，同时 <code>begin</code>、<code>end</code>、<code>front</code>、<code>back</code> 成员函数指向的位置也和 <code>string</code> 一样，大致如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/24/10/247951f886561c30ced2eb7700f9d510.png" alt=""></p><p>除了容器类的共同点，<code>vector</code> 允许下面的操作（不完全列表）：</p><ul>
<li>可以使用中括号的下标来访问其成员（同 <code>string</code>）</li>
<li>可以使用 <code>data</code> 来获得指向其内容的裸指针（同 <code>string</code>）</li>
<li>可以使用 <code>capacity</code> 来获得当前分配的存储空间的大小，以元素数量计（同 <code>string</code>）</li>
<li>可以使用 <code>reserve</code> 来改变所需的存储空间的大小，成功后 <code>capacity()</code> 会改变（同 <code>string</code>）</li>
<li>可以使用 <code>resize</code> 来改变其大小，成功后 <code>size()</code> 会改变（同 <code>string</code>）</li>
<li>可以使用 <code>pop_back</code> 来删除最后一个元素（同 <code>string</code>）</li>
<li>可以使用 <code>push_back</code> 在尾部插入一个元素（同 <code>string</code>）</li>
<li>可以使用 <code>insert</code> 在指定位置前插入一个元素（同 <code>string</code>）</li>
<li>可以使用 <code>erase</code> 在指定位置删除一个元素（同 <code>string</code>）</li>
<li>可以使用 <code>emplace</code> 在指定位置构造一个元素</li>
<li>可以使用 <code>emplace_back</code> 在尾部新构造一个元素</li>
</ul><p>大家可以留意一下 <code>push_…</code> 和 <code>pop_…</code> 成员函数。它们存在时，说明容器对指定位置的删除和插入性能较高。<code>vector</code> 适合在尾部操作，这是它的内存布局决定的。只有在尾部插入和删除时，其他元素才会不需要移动，除非内存空间不足导致需要重新分配内存空间。</p><p>当 <code>push_back</code>、<code>insert</code>、<code>reserve</code>、<code>resize</code> 等函数导致内存重分配时，或当 <code>insert</code>、<code>erase</code> 导致元素位置移动时，<code>vector</code> 会试图把元素“移动”到新的内存区域。<code>vector</code> 通常保证强异常安全性，如果元素类型没有提供一个<strong>保证不抛异常的移动构造函数</strong>，<code>vector</code> 通常会使用拷贝构造函数。因此，对于拷贝代价较高的自定义元素类型，我们应当定义移动构造函数，并标其为 <code>noexcept</code>，或只在容器中放置对象的智能指针。这就是为什么我之前需要在 <code>smart_ptr</code> 的实现中标上 <code>noexcept</code> 的原因。</p><p>下面的代码可以演示这一行为：</p><pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

class Obj1 {
public:
  Obj1()
  {
    cout &lt;&lt; "Obj1()\n";
  }
  Obj1(const Obj1&amp;)
  {
    cout &lt;&lt; "Obj1(const Obj1&amp;)\n";
  }
  Obj1(Obj1&amp;&amp;)
  {
    cout &lt;&lt; "Obj1(Obj1&amp;&amp;)\n";
  }
};

class Obj2 {
public:
  Obj2()
  {
    cout &lt;&lt; "Obj2()\n";
  }
  Obj2(const Obj2&amp;)
  {
    cout &lt;&lt; "Obj2(const Obj2&amp;)\n";
  }
  Obj2(Obj2&amp;&amp;) noexcept
  {
    cout &lt;&lt; "Obj2(Obj2&amp;&amp;)\n";
  }
};

int main()
{
  vector&lt;Obj1&gt; v1;
  v1.reserve(2);
  v1.emplace_back();
  v1.emplace_back();
  v1.emplace_back();

  vector&lt;Obj2&gt; v2;
  v2.reserve(2);
  v2.emplace_back();
  v2.emplace_back();
  v2.emplace_back();
}
</code></pre><p>我们可以立即得到下面的输出：</p><blockquote>
<p><code>Obj1()</code><br>
<code>Obj1()</code><br>
<code>Obj1()</code><br>
<code>Obj1(const Obj1&amp;)</code><br>
<code>Obj1(const Obj1&amp;)</code><br>
<code>Obj2()</code><br>
<code>Obj2()</code><br>
<code>Obj2()</code><br>
<code>Obj2(Obj2&amp;&amp;)</code><br>
<code>Obj2(Obj2&amp;&amp;)</code></p>
</blockquote><p><code>Obj1</code> 和 <code>Obj2</code> 的定义只差了一个 <code>noexcept</code>，但这个小小的差异就导致了 <code>vector</code> 是否会移动对象。这点非常重要。</p><p>C++11 开始提供的 <code>emplace…</code> 系列函数是为了提升容器的性能而设计的。你可以试试把 <code>v1.emplace_back()</code> 改成 <code>v1.push_back(Obj1())</code>。对于 <code>vector</code> 里的内容，结果是一样的；但使用 <code>push_back</code> 会额外生成临时对象，多一次拷贝构造和一次析构。</p><p>现代处理器的体系架构使得对连续内存访问的速度比不连续的内存要快得多。因而，<code>vector</code> 的连续内存使用是它的一大优势所在。当你不知道该用什么容器时，缺省就使用 <code>vector</code> 吧。</p><p><code>vector</code> 的一个主要缺陷是大小增长时导致的元素移动。如果可能，尽早使用 <code>reserve</code> 函数为 <code>vector</code> 保留所需的内存，这在 <code>vector</code> 预期会增长很大时能带来很大的性能提升。</p><h2>deque</h2><p><code>deque</code> 的意思是 double-ended queue，双端队列。它主要是用来满足下面这个需求：</p><ul>
<li>容器不仅可以从尾部自由地添加和删除元素，也可以从头部自由地添加和删除。</li>
</ul><p><code>deque</code> 的接口和 <code>vector</code> 相比，有如下的区别：</p><ul>
<li><code>deque</code> 提供 <code>push_front</code>、<code>emplace_front</code> 和 <code>pop_front</code> 成员函数。</li>
<li><code>deque</code> 不提供 <code>data</code>、<code>capacity</code> 和 <code>reserve</code> 成员函数。</li>
</ul><p><code>deque</code> 的内存布局一般是这样的：</p><p><img src="https://static001.geekbang.org/resource/image/ae/a1/aea92e7e005d65fa56d6332bb7706fa1.png" alt=""></p><p>可以看到：</p><ul>
<li>如果只从头、尾两个位置对 <code>deque</code> 进行增删操作的话，容器里的对象永远不需要移动。</li>
<li>容器里的元素只是部分连续的（因而没法提供 <code>data</code> 成员函数）。</li>
<li>由于元素的存储大部分仍然连续，它的遍历性能是比较高的。</li>
<li>由于每一段存储大小相等，<code>deque</code> 支持使用下标访问容器元素，大致相当于 <code>index[i / chunk_size][i % chunk_size]</code>，也保持高效。</li>
</ul><p>如果你需要一个经常在头尾增删元素的容器，那 <code>deque</code> 会是个合适的选择。</p><h2>list</h2><p><code>list</code> 在 C++ 里代表双向链表。和 <code>vector</code> 相比，它优化了在容器中间的插入和删除：</p><ul>
<li><code>list</code> 提供高效的、O(1) 复杂度的任意位置的插入和删除操作。</li>
<li><code>list</code> 不提供使用下标访问其元素。</li>
<li><code>list</code> 提供 <code>push_front</code>、<code>emplace_front</code> 和 <code>pop_front</code> 成员函数（和 <code>deque</code> 相同）。</li>
<li><code>list</code> 不提供 <code>data</code>、<code>capacity</code> 和 <code>reserve</code> 成员函数（和 <code>deque</code> 相同）。</li>
</ul><p>它的内存布局一般是下图这个样子：</p><p><img src="https://static001.geekbang.org/resource/image/ad/14/addb521e20de1a302206f4286eac3914.png" alt=""></p><p>需要指出的是，虽然 <code>list</code> 提供了任意位置插入新元素的灵活性，但由于每个元素的内存空间都是单独分配、不连续，它的遍历性能比 <code>vector</code> 和 <code>deque</code> 都要低。这在很大程度上抵消了它在插入和删除操作时不需要移动元素的理论性能优势。如果你不太需要遍历容器、又需要在中间频繁插入或删除元素，可以考虑使用 <code>list</code>。</p><p>另外一个需要注意的地方是，因为某些标准算法在 <code>list</code> 上会导致问题，list 提供了成员函数作为替代，包括下面几个：</p><ul>
<li><code>merge</code></li>
<li><code>remove</code></li>
<li><code>remove_if</code></li>
<li><code>reverse</code></li>
<li><code>sort</code></li>
<li><code>unique</code></li>
</ul><p>下面是一个示例（以 xeus-cling 的交互为例）：</p><pre><code class="language-c++">#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
using namespace std;
</code></pre><pre><code class="language-c++">list&lt;int&gt; lst{1, 7, 2, 8, 3};
vector&lt;int&gt; vec{1, 7, 2, 8, 3};
</code></pre><pre><code class="language-c++">sort(vec.begin(), vec.end());     // 正常
// sort(lst.begin(), lst.end());  // 会出错
lst.sort();                       // 正常
</code></pre><pre><code class="language-c++">lst  // 输出 { 1, 2, 3, 7, 8 }
</code></pre><pre><code class="language-c++">vec  // 输出 { 1, 2, 3, 7, 8 }
</code></pre><p>如果不用 xeus-cling 的话，我们需要做点转换：</p><ul>
<li>把 <code>using namespace std;</code> 后面的部分放到 <code>main</code> 函数里。</li>
<li>文件开头加上 <code>#include "output_container.h"</code> 和 <code>#include &lt;iostream&gt;</code>。</li>
<li>把输出语句改写成 <code>cout &lt;&lt; … &lt;&lt; endl;</code>。</li>
</ul><p>这次我会给一下改造的示例（下次就请你自行改写了😉）：</p><pre><code class="language-c++">#include "output_container.h"
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
using namespace std;

int main()
{
  list&lt;int&gt; lst{1, 7, 2, 8, 3};
  vector&lt;int&gt; vec{1, 7, 2, 8, 3};

  sort(vec.begin(), vec.end());    // 正常
  // sort(lst.begin(), lst.end()); // 会出错
  lst.sort();                      // 正常

  cout &lt;&lt; lst &lt;&lt; endl;
  // 输出 { 1, 2, 3, 7, 8 }

  cout &lt;&lt; vec &lt;&lt; endl;
  // 输出 { 1, 2, 3, 7, 8 }
}
</code></pre><h2>forward_list</h2><p>既然 <code>list</code> 是双向链表，那么 C++ 里有没有单向链表呢？答案是肯定的。从 C++11 开始，前向列表 <code>forward_list</code> 成了标准的一部分。</p><p>我们先看一下它的内存布局：</p><p><img src="https://static001.geekbang.org/resource/image/ef/4e/ef23c4d60940c170629cf65771df084e.png" alt=""></p><p>大部分 C++ 容器都支持 <code>insert</code> 成员函数，语义是从指定的位置之前插入一个元素。对于 <code>forward_list</code>，这不是一件容易做到的事情（想一想，为什么？）。标准库提供了一个 <code>insert_after</code> 作为替代。此外，它跟 <code>list</code> 相比还缺了下面这些成员函数：</p><ul>
<li><code>back</code></li>
<li><code>size</code></li>
<li><code>push_back</code></li>
<li><code>emplace_back</code></li>
<li><code>pop_back</code></li>
</ul><p>为什么会需要这么一个阉割版的 list 呢？原因是，在元素大小较小的情况下，<code>forward_list</code> 能节约的内存是非常可观的；在列表不长的情况下，不能反向查找也不是个大问题。提高内存利用率，往往就能提高程序性能，更不用说在内存可能不足时的情况了。</p><p>目前你只需要知道这个东西的存在就可以了。如果你觉得不需要用到它的话，也许你真的不需要它。</p><h2>queue</h2><p>在结束本讲之前，我们再快速讲两个类容器。它们的特别点在于它们都不是完整的实现，而是依赖于某个现有的容器，因而被称为容器适配器（container adaptor）。</p><p>我们先看一下队列 <code>queue</code>，先进先出（FIFO）的数据结构。</p><p><code>queue</code> 缺省用 <code>deque</code> 来实现。它的接口跟 <code>deque</code> 比，有如下改变：</p><ul>
<li>不能按下标访问元素</li>
<li>没有 <code>begin</code>、<code>end</code> 成员函数</li>
<li>用 <code>emplace</code> 替代了 <code>emplace_back</code>，用 <code>push</code> 替代了 <code>push_back</code>，用 <code>pop</code> 替代了 <code>pop_front</code>；没有其他的 <code>push_…</code>、<code>pop_…</code>、<code>emplace…</code>、<code>insert</code>、<code>erase</code> 函数</li>
</ul><p>它的实际内存布局当然是随底层的容器而定的。从概念上讲，它的结构可如下所示：</p><p><img src="https://static001.geekbang.org/resource/image/09/ff/090f23e3b4cdd8d297e4b970cbbf6cff.png" alt=""></p><p>鉴于 <code>queue</code> 不提供 <code>begin</code> 和 <code>end</code> 方法，无法无损遍历，我们只能用下面的代码约略展示一下其接口：</p><pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;queue&gt;

int main()
{
  std::queue&lt;int&gt; q;
  q.push(1);
  q.push(2);
  q.push(3);
  while (!q.empty()) {
    std::cout &lt;&lt; q.front()
              &lt;&lt; std::endl;
    q.pop();
  }
}
</code></pre><p>这个代码的输出就不用解释了吧。哈哈。</p><h2>stack</h2><p>类似地，栈 <code>stack</code> 是后进先出（LIFO）的数据结构。</p><p><code>queue</code> 缺省也是用 <code>deque</code> 来实现，但它的概念和 <code>vector</code> 更相似。它的接口跟 <code>vector</code> 比，有如下改变：</p><ul>
<li>不能按下标访问元素</li>
<li>没有 <code>begin</code>、<code>end</code> 成员函数</li>
<li><code>back</code> 成了 <code>top</code>，没有 <code>front</code></li>
<li>用 <code>emplace</code> 替代了 <code>emplace_back</code>，用 <code>push</code> 替代了 <code>push_back</code>，用 <code>pop</code> 替代了 <code>pop_back</code>；没有其他的 <code>push_…</code>、<code>pop_…</code>、<code>emplace…</code>、<code>insert</code>、<code>erase</code> 函数</li>
</ul><p>一般图形表示法会把 <code>stack</code> 表示成一个竖起的 <code>vector</code>：</p><p><img src="https://static001.geekbang.org/resource/image/68/47/68026091ff5eacac00c49d75151fff47.png" alt=""></p><p>这里有一个小细节需要注意。<code>stack</code> 跟我们前面讨论内存管理时的栈有一个区别：在这里下面是低地址，向上则地址增大；而我们讨论内存管理时，高地址在下面，向上则地址减小，方向正好相反。提这一点，是希望你在有需要检查栈结构时不会因此而发生混淆；在使用 <code>stack</code> 时，这个区别通常无关紧要。</p><p>示例代码和上面的 <code>stack</code> 相似，但输出正好相反：</p><pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;stack&gt;

int main()
{
  std::stack&lt;int&gt; s;
  s.push(1);
  s.push(2);
  s.push(3);
  while (!s.empty()) {
    std::cout &lt;&lt; s.top()
              &lt;&lt; std::endl;
    s.pop();
  }
}
</code></pre><h2>内容小结</h2><p>本讲我们介绍了 C++ 里面的序列容器和两个容器适配器。通过本讲的介绍，你应该已经对容器有了一定的理解和认识。下一讲我们会讲完剩余的标准容器。</p><h2>课后思考</h2><p>留几个问题请你思考一下：</p><ol>
<li>今天讲的容器有哪些共同的特点？</li>
<li>为什么 C++ 有这么多不同的序列容器类型？</li>
<li>为什么 <code>stack</code>（或 <code>queue</code>）的 <code>pop</code> 函数返回类型为 <code>void</code>，而不是直接返回容器的 <code>top</code>（或 <code>front</code>）成员？</li>
</ol><p>欢迎留言和我交流你的看法。</p><h2><span class="reference">参考资料</span></h2><p><span class="reference">[1] cppreference.com, “Containers library”. <a href="https://en.cppreference.com/w/cpp/container">https://en.cppreference.com/w/cpp/container</a> </span></p><p><span class="reference">[1a] cppreference.com, “容器库”. <a href="https://zh.cppreference.com/w/cpp/container">https://zh.cppreference.com/w/cpp/container</a> </span></p><p><span class="reference">[2] QuantStack, xeus-cling. <a href="https://github.com/QuantStack/xeus-cling">https://github.com/QuantStack/xeus-cling</a> </span></p><p><span class="reference">[3] 吴咏炜, output_container. <a href="https://github.com/adah1972/output_container/blob/master/output_container.h">https://github.com/adah1972/output_container/blob/master/output_container.h</a> </span></p><h2>精选留言：</h2>
        <ul>
        
<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            YouCompleteMe  2019-12-04 12:45:28
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            1.都是线性容器<br>2.不同容器功能，效率不一样<br>3.实现pop时返回元素时，满足强异常安全，代码实现复杂，可读性差。 [8赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-04 21:03:52</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">3的正解终于出现，有人说到“异常安全”了。👍<br><br>再说两句，这是C++98时设计的接口，没有移动就只能那样。有了移动，在多线程的环境里，移动返回加弹出实际上就变得有用了。我对复杂和可读性部分不那么同意。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            中年男子  2019-12-04 23:48:09
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            我发现老师的问题基本都可以在文章中找到答案，<br>1、2就不说了，3说一下我的理解:引用老师在vector那段的话 stack(queue)为保证强异常安全性，如果元素类型没有提供一个保证不抛异常的移动构造函数， 通常会使用拷贝构造函数，而pop作用是释放元素，c++98还没有移动构造的概念，所以如果返回成员，必须要调用拷贝构造函数，这时分配空间可能出错，导致构造失败，要抛出异常，所以没必要返回成员。 [3赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-05 09:29:11</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">很棒👌。<br><br>异常安全是关键。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            徐凯  2019-12-04 09:52:31
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            第一个问题 今天讲的大多是线性结构的容器，也可以说大多是非关联容器<br><br>第二个问题  应该不只是c++  所有语言都提供了，之所以对其封装是便于使用，不需要用户自己去造轮子。同时有些容器内部有迭代器 与stl算法相结合可以便于实现泛型编程。c++委员会想让c++成为一个多元化的语言支持 面向对象 面向过程 泛型编程<br><br>第三个问题 将对容器的操作与获取值的操作分离开，用途会更明确。同时pop由于已经从容器中剔除了那个元素，那么返回的只能是个拷贝不允许返回已销毁元素的引用。这意味着需要一次拷贝构造操作。而top只需要返回指定元素的引用，高效简洁。将两次操作分开使得操作更明确同时没有额外开销。<br><br>个人见解  请老师赐教😃 [3赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-04 12:57:45</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">挺好。三比其他回答已经进一步了，但还是没有触及到某个关键字。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            禾桃  2019-12-05 11:13:51
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            请教一个问题，<br>#1<br>为什么一定强制移动构造函数不要抛出异常？<br>移动构造函数抛出异常后，catch处理不可以吗？<br><br>#2<br>为什么拷贝构造函数被允许抛出异常？<br><br>能麻烦给些代码说明一下吗？<br><br>非常感谢！ [1赞]
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-05 18:00:16</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">catch住也没有用了。仔细想一下，我现在要把vector里的两个对象移到一个新的vector，移第一个成功，第二个时有异常，然后vector该怎么办？现在两个vector都废掉了。<br><br>拷贝不影响旧的容器。即使发生异常，至少老的那个还是好的。这就是异常安全。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            虫 二  2019-12-04 21:51:25
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            1.本章节大部分都是非关联容器<br>2.各容器效率不同，为了方便使用应用在不同的场景之中<br>3.在某些特定情况下会引发异常问题<br> 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-05 09:42:59</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">可以。够言简意赅的。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            糖  2019-12-04 20:39:40
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            1.线性容器<br>2.由于不同场景下需要有合适的数据结构与之对应，比如既然有了deque为何会有queue和stack呢，queue和stack的功能deque也能实现，而且甚至比queue和stack具有更大的自由，这是由于在很多情况下接口的自由使得犯错误的几率也就变大，因此将大多数接口都封装起来来减小出错的可能性。以及链表、数组都存在也是因为他们都具有不可代替的一面。<br>3.JAVA中确实是当pop时返回被pop的值，而C++中并没有返回该值，我认为很大程度上是由于C++更注重效率，毕竟这样做可以减小一次拷贝或者移动，当容器中存储的对象拷贝或移动很费劲或者多次pop时，这将大大降低C++的pop速度。另外我认为可能和异常的避免有关，由于如果需要返回被pop的值，需要提前将其拷贝到其他地方或者是移动到其他地方，这两者都可能需要内存的分配，所以可能会出现异常。第二点纯属脑洞，不清楚自己考虑的对不对，希望老师指正。。。 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-05 09:39:54</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">还是重点谈3。对于C++的情况，基本没问题。对于Java，则错了。Java的情况最接近于你返回一个智能指针——这个操作本身性能是没问题的。主要约束是必须在堆上放置对象。<br><br>2 你对防犯错的考虑非常好。其他人似乎没提到。👍</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            传说中的成大大  2019-12-04 20:18:41
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            然后第三问 我看了留言 和你的提示 我确切的说是避免临时对象的构造和析构 提高性能 毕竟我们Pop掉过后就不需要了 这个回答满分 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-04 21:36:08</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">嘿嘿，还漏了个关键字。见YouCompleteMe的回答。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            传说中的成大大  2019-12-04 20:17:16
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            第一问我可以调皮的回答是 都是对对象的一种存储和管理嘛 哈哈哈<br>第二问 大概是为了满足不同的操作方式 比如有些需要先进先出 有些需要后进先出 有些需要随机访问等等<br>第三问 我大胆猜想 要分开处理的原因 有的时候我们只需访问一下top或者front数据 而不是弹出 所以需要一个获取 既然已经有了获取 弹出的时候就不需要再拿到这个数字了, 如果用pop可以返回元素 栈顶元素就只能正确的访问一次 再一次访问时 栈顶元素就不对了 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-04 21:20:08</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">一、二没有标准答案。三的关键字见YouCompleteMe的回答。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            传说中的成大大  2019-12-04 20:11:19
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            这节课的内容就浅显多了嘛  不过通过这节课的讲解vector的push_back反而我更能理解右值引用就是为了解决临时变量的拷贝构造和析构从而产生的性能问题 而移动则是为了解决像vector扩容后的拷贝到新内存区域的时候这个耗性能的过程 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-04 21:18:55</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">教知识是我的目的，而不是难倒你们哦。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            Zephyr  2019-12-04 19:13:49
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            container.h 404了老师 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-04 20:52:41</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">谢谢报告。编辑已经修复链接。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            皮皮侠  2019-12-04 18:49:19
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            老师，C++11里的“stream流”是不是真的有缺陷，只能在测试等环境下用用？C++后续对此有改进么？ 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-04 21:16:06</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">没有问题的。除了写出来的样子有时候不那么方便，输出项多时性能不那么高，完全可用，毕竟有灵活性和类型安全性。<br><br>C++20 会引入新的机制，类似于printf系列但类型安全。见：<br><br>https:&#47;&#47;en.cppreference.com&#47;w&#47;cpp&#47;utility&#47;format</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            罗乾林  2019-12-04 17:08:35
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            1、这些容器中元素能拉成一条链<br>2、为了方便使用😂<br>3、pop（）的同时删除元素并返回，返回的时候分配内存，可能失败，而此时对象已经从容器中删除，导致元素丢失 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-04 21:09:50</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">你的3也接近了。关键字见YouCompleteMe的回答。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            lyfei  2019-12-04 16:55:49
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            为什么我使用output_container.h的时候出现了错误：<br>我应该开启了c++17标准了（我用的编辑器是CLion，编译器是g++）[但是我不太清楚是否真的开启了]<br><br>error: ‘is_pair_v’ declared as an ‘inline’ variable 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-04 21:54:37</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">GCC 版本是多少？我在老版本的 GCC 上能复现这个问题。<br><br>请使用 GCC 7 以上版本。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            方阳  2019-12-04 16:37:37
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            第三个问题，pop函数的意思是为了移除栈顶的元素，有这种情况，不想移除栈顶元素，只是想用栈顶的元素，如果用pop函数返回出元素，还需要再压入栈中，这造成了浪费，所以提供top函数访问栈顶元素。 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-04 21:09:16</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">这个只解释了为什么要有top，没解释为什么pop不可以“顺便”返回弹出的对象。<br><br>关键字见YouCompleteMe的回答。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            廖熊猫  2019-12-04 14:20:59
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            1. 除了老师总结这些我认为些容器都是具有顺序的吧。<br>2. 这么多容器都是抽象数据结构的实现吧，这些比较常用，为了方便（?）就给实现出来了（瞎猜的..）<br>3. top还有其他容器通过下标以及front，back返回的都是数据的引用，如果pop还要返回的话就会引发复制了，通过top返回可以在适用的场景由自己决定是不是要复制这个对象，不然的话不管需要不需要，每次pop都会复制对象了，会造成浪费 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-04 21:07:33</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">1、2实际上没标准答案，是引大家思考的。3要“得分”的话，关键字……见YouCompleteMe的回答。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            舍得  2019-12-04 14:08:14
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            重载运算符就可以输出自定义类型了 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-04 21:00:14</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">你可以试试通用地写这个输出运算符。我写这个还是花了点力气的。😎</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            小一日一  2019-12-04 11:31:47
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            老师漏了C++11新增加的array容器 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-04 20:56:02</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">不急，下一讲就来。🤐</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            hello world  2019-12-04 07:34:38
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            1.今天讲的都是非关联容器，不像map这种可以关联起数据<br>2.因为不同的容器类型底层的数据结构不同，适用于不同的场景，连续内存支持下边访问基本不在开头和中间插入删除那就基本上vector，频繁中间插入删除数据量又比较大那就可以考虑list，头尾增删可以考虑deque等<br>3. 可能是没有必要？明明已经有top了，返回对象类型必然要实例化，浪费性能<br>另外有个问题，关于vector的那段示例代码，各种感觉会分别调用三次构造三次拷贝以及三次构造三次移动。为什么是三次构造二次移动和拷贝呢 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-04 12:54:34</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">3 再想想。提示：这个接口设计是 C++98 时的老设计。<br><br>两者都是要构造第 3 个对象时空间不足，需要这样：<br><br>1. 分配一个足够大的新内存区域。<br>2. 在上面构造第 3 个对象。<br>3. 如果成功（没有异常），再移动&#47;拷贝旧的对象。<br>4. 全部成功，则析构旧对象，释放旧对象的内存。<br>5. 如果 1 出现异常，直接抛出即可；如果 2–3 出现异常，则析构已成功构造的对象，释放新内存空间，继续抛出异常。</div>
</div>
            
    </div>
</li>
            
<br/>

<li>
    <div>
        <div style="color: #888;font-size:15.25px;font-weight:400;            line-height:1.2">
            Vackine  2019-12-04 00:44:14
        </div>
        <div style="color:#353535;font-weight:400;white-space:normal;            word-break:break-all;line-height:1.6">
            1. 线性的数据结构，其实际的抽象模型对应数组个链表的数据结构。<br>2. 满足动态进行插入删除的需求，当然是C++标准想对各种基础常用的数据结构都进行封装(😂猜的)。<br>3. 因为C++标准库容器的实现都是模板类的，为了提供泛型编程的模式。<br><br>以上内容还有很多不确信的，还请老师指正。 
        </div>
        <br/>
<div>
    <div style="color:#888;font-size:15.25px;font-weight:400;        line-height:1.2">作者回复2019-12-04 07:26:21</div>
    <div style="color:#353535;font-weight:400;white-space:normal;        word-break:break-all;line-height:1.6">动作很快啊。<br><br>1. 大体上对。再留意一下它们的方法。<br><br>2. 不完全对。再想想。<br><br>3. 不是这个原因。🤓</div>
</div>
            
    </div>
</li>
            </ul>
</div>
</body>
</html>